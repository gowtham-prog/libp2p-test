{
  "version": 3,
  "sources": ["../../../../../node_modules/node-forge/lib/sha256.js", "../../../../../node_modules/node-forge/lib/prng.js", "../../../../../node_modules/node-forge/lib/random.js", "../../../../../node_modules/node-forge/lib/sha1.js", "../../../../../node_modules/node-forge/lib/pkcs1.js", "../../../../../node_modules/node-forge/lib/prime.js", "../../../../../node_modules/node-forge/lib/rsa.js"],
  "sourcesContent": ["/**\n * Secure Hash Algorithm with 256-bit digest (SHA-256) implementation.\n *\n * See FIPS 180-2 for details.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2015 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./md');\nrequire('./util');\n\nvar sha256 = module.exports = forge.sha256 = forge.sha256 || {};\nforge.md.sha256 = forge.md.algorithms.sha256 = sha256;\n\n/**\n * Creates a SHA-256 message digest object.\n *\n * @return a message digest object.\n */\nsha256.create = function() {\n  // do initialization as necessary\n  if(!_initialized) {\n    _init();\n  }\n\n  // SHA-256 state contains eight 32-bit integers\n  var _state = null;\n\n  // input buffer\n  var _input = forge.util.createBuffer();\n\n  // used for word storage\n  var _w = new Array(64);\n\n  // message digest object\n  var md = {\n    algorithm: 'sha256',\n    blockLength: 64,\n    digestLength: 32,\n    // 56-bit length of message so far (does not including padding)\n    messageLength: 0,\n    // true message length\n    fullMessageLength: null,\n    // size of message length in bytes\n    messageLengthSize: 8\n  };\n\n  /**\n   * Starts the digest.\n   *\n   * @return this digest object.\n   */\n  md.start = function() {\n    // up to 56-bit message length for convenience\n    md.messageLength = 0;\n\n    // full message length (set md.messageLength64 for backwards-compatibility)\n    md.fullMessageLength = md.messageLength64 = [];\n    var int32s = md.messageLengthSize / 4;\n    for(var i = 0; i < int32s; ++i) {\n      md.fullMessageLength.push(0);\n    }\n    _input = forge.util.createBuffer();\n    _state = {\n      h0: 0x6A09E667,\n      h1: 0xBB67AE85,\n      h2: 0x3C6EF372,\n      h3: 0xA54FF53A,\n      h4: 0x510E527F,\n      h5: 0x9B05688C,\n      h6: 0x1F83D9AB,\n      h7: 0x5BE0CD19\n    };\n    return md;\n  };\n  // start digest automatically for first time\n  md.start();\n\n  /**\n   * Updates the digest with the given message input. The given input can\n   * treated as raw input (no encoding will be applied) or an encoding of\n   * 'utf8' maybe given to encode the input using UTF-8.\n   *\n   * @param msg the message input to update with.\n   * @param encoding the encoding to use (default: 'raw', other: 'utf8').\n   *\n   * @return this digest object.\n   */\n  md.update = function(msg, encoding) {\n    if(encoding === 'utf8') {\n      msg = forge.util.encodeUtf8(msg);\n    }\n\n    // update message length\n    var len = msg.length;\n    md.messageLength += len;\n    len = [(len / 0x100000000) >>> 0, len >>> 0];\n    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {\n      md.fullMessageLength[i] += len[1];\n      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) >>> 0);\n      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\n      len[0] = ((len[1] / 0x100000000) >>> 0);\n    }\n\n    // add bytes to input buffer\n    _input.putBytes(msg);\n\n    // process bytes\n    _update(_state, _w, _input);\n\n    // compact input buffer every 2K or if empty\n    if(_input.read > 2048 || _input.length() === 0) {\n      _input.compact();\n    }\n\n    return md;\n  };\n\n  /**\n   * Produces the digest.\n   *\n   * @return a byte buffer containing the digest value.\n   */\n  md.digest = function() {\n    /* Note: Here we copy the remaining bytes in the input buffer and\n    add the appropriate SHA-256 padding. Then we do the final update\n    on a copy of the state so that if the user wants to get\n    intermediate digests they can do so. */\n\n    /* Determine the number of bytes that must be added to the message\n    to ensure its length is congruent to 448 mod 512. In other words,\n    the data to be digested must be a multiple of 512 bits (or 128 bytes).\n    This data includes the message, some padding, and the length of the\n    message. Since the length of the message will be encoded as 8 bytes (64\n    bits), that means that the last segment of the data must have 56 bytes\n    (448 bits) of message and padding. Therefore, the length of the message\n    plus the padding must be congruent to 448 mod 512 because\n    512 - 128 = 448.\n\n    In order to fill up the message length it must be filled with\n    padding that begins with 1 bit followed by all 0 bits. Padding\n    must *always* be present, so if the message length is already\n    congruent to 448 mod 512, then 512 padding bits must be added. */\n\n    var finalBlock = forge.util.createBuffer();\n    finalBlock.putBytes(_input.bytes());\n\n    // compute remaining size to be digested (include message length size)\n    var remaining = (\n      md.fullMessageLength[md.fullMessageLength.length - 1] +\n      md.messageLengthSize);\n\n    // add padding for overflow blockSize - overflow\n    // _padding starts with 1 byte with first bit is set (byte value 128), then\n    // there may be up to (blockSize - 1) other pad bytes\n    var overflow = remaining & (md.blockLength - 1);\n    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\n\n    // serialize message length in bits in big-endian order; since length\n    // is stored in bytes we multiply by 8 and add carry from next int\n    var next, carry;\n    var bits = md.fullMessageLength[0] * 8;\n    for(var i = 0; i < md.fullMessageLength.length - 1; ++i) {\n      next = md.fullMessageLength[i + 1] * 8;\n      carry = (next / 0x100000000) >>> 0;\n      bits += carry;\n      finalBlock.putInt32(bits >>> 0);\n      bits = next >>> 0;\n    }\n    finalBlock.putInt32(bits);\n\n    var s2 = {\n      h0: _state.h0,\n      h1: _state.h1,\n      h2: _state.h2,\n      h3: _state.h3,\n      h4: _state.h4,\n      h5: _state.h5,\n      h6: _state.h6,\n      h7: _state.h7\n    };\n    _update(s2, _w, finalBlock);\n    var rval = forge.util.createBuffer();\n    rval.putInt32(s2.h0);\n    rval.putInt32(s2.h1);\n    rval.putInt32(s2.h2);\n    rval.putInt32(s2.h3);\n    rval.putInt32(s2.h4);\n    rval.putInt32(s2.h5);\n    rval.putInt32(s2.h6);\n    rval.putInt32(s2.h7);\n    return rval;\n  };\n\n  return md;\n};\n\n// sha-256 padding bytes not initialized yet\nvar _padding = null;\nvar _initialized = false;\n\n// table of constants\nvar _k = null;\n\n/**\n * Initializes the constant tables.\n */\nfunction _init() {\n  // create padding\n  _padding = String.fromCharCode(128);\n  _padding += forge.util.fillString(String.fromCharCode(0x00), 64);\n\n  // create K table for SHA-256\n  _k = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n\n  // now initialized\n  _initialized = true;\n}\n\n/**\n * Updates a SHA-256 state with the given byte buffer.\n *\n * @param s the SHA-256 state to update.\n * @param w the array to use to store words.\n * @param bytes the byte buffer to update with.\n */\nfunction _update(s, w, bytes) {\n  // consume 512 bit (64 byte) chunks\n  var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;\n  var len = bytes.length();\n  while(len >= 64) {\n    // the w array will be populated with sixteen 32-bit big-endian words\n    // and then extended into 64 32-bit words according to SHA-256\n    for(i = 0; i < 16; ++i) {\n      w[i] = bytes.getInt32();\n    }\n    for(; i < 64; ++i) {\n      // XOR word 2 words ago rot right 17, rot right 19, shft right 10\n      t1 = w[i - 2];\n      t1 =\n        ((t1 >>> 17) | (t1 << 15)) ^\n        ((t1 >>> 19) | (t1 << 13)) ^\n        (t1 >>> 10);\n      // XOR word 15 words ago rot right 7, rot right 18, shft right 3\n      t2 = w[i - 15];\n      t2 =\n        ((t2 >>> 7) | (t2 << 25)) ^\n        ((t2 >>> 18) | (t2 << 14)) ^\n        (t2 >>> 3);\n      // sum(t1, word 7 ago, t2, word 16 ago) modulo 2^32\n      w[i] = (t1 + w[i - 7] + t2 + w[i - 16]) | 0;\n    }\n\n    // initialize hash value for this chunk\n    a = s.h0;\n    b = s.h1;\n    c = s.h2;\n    d = s.h3;\n    e = s.h4;\n    f = s.h5;\n    g = s.h6;\n    h = s.h7;\n\n    // round function\n    for(i = 0; i < 64; ++i) {\n      // Sum1(e)\n      s1 =\n        ((e >>> 6) | (e << 26)) ^\n        ((e >>> 11) | (e << 21)) ^\n        ((e >>> 25) | (e << 7));\n      // Ch(e, f, g) (optimized the same way as SHA-1)\n      ch = g ^ (e & (f ^ g));\n      // Sum0(a)\n      s0 =\n        ((a >>> 2) | (a << 30)) ^\n        ((a >>> 13) | (a << 19)) ^\n        ((a >>> 22) | (a << 10));\n      // Maj(a, b, c) (optimized the same way as SHA-1)\n      maj = (a & b) | (c & (a ^ b));\n\n      // main algorithm\n      t1 = h + s1 + ch + _k[i] + w[i];\n      t2 = s0 + maj;\n      h = g;\n      g = f;\n      f = e;\n      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n      // can't truncate with `| 0`\n      e = (d + t1) >>> 0;\n      d = c;\n      c = b;\n      b = a;\n      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n      // can't truncate with `| 0`\n      a = (t1 + t2) >>> 0;\n    }\n\n    // update hash state\n    s.h0 = (s.h0 + a) | 0;\n    s.h1 = (s.h1 + b) | 0;\n    s.h2 = (s.h2 + c) | 0;\n    s.h3 = (s.h3 + d) | 0;\n    s.h4 = (s.h4 + e) | 0;\n    s.h5 = (s.h5 + f) | 0;\n    s.h6 = (s.h6 + g) | 0;\n    s.h7 = (s.h7 + h) | 0;\n    len -= 64;\n  }\n}\n", "/**\n * A javascript implementation of a cryptographically-secure\n * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed\n * here though the use of SHA-256 is not enforced; when generating an\n * a PRNG context, the hashing algorithm and block cipher used for\n * the generator are specified via a plugin.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\n\nvar _crypto = null;\nif(forge.util.isNodejs && !forge.options.usePureJavaScript &&\n  !process.versions['node-webkit']) {\n  _crypto = require('crypto');\n}\n\n/* PRNG API */\nvar prng = module.exports = forge.prng = forge.prng || {};\n\n/**\n * Creates a new PRNG context.\n *\n * A PRNG plugin must be passed in that will provide:\n *\n * 1. A function that initializes the key and seed of a PRNG context. It\n *   will be given a 16 byte key and a 16 byte seed. Any key expansion\n *   or transformation of the seed from a byte string into an array of\n *   integers (or similar) should be performed.\n * 2. The cryptographic function used by the generator. It takes a key and\n *   a seed.\n * 3. A seed increment function. It takes the seed and returns seed + 1.\n * 4. An api to create a message digest.\n *\n * For an example, see random.js.\n *\n * @param plugin the PRNG plugin to use.\n */\nprng.create = function(plugin) {\n  var ctx = {\n    plugin: plugin,\n    key: null,\n    seed: null,\n    time: null,\n    // number of reseeds so far\n    reseeds: 0,\n    // amount of data generated so far\n    generated: 0,\n    // no initial key bytes\n    keyBytes: ''\n  };\n\n  // create 32 entropy pools (each is a message digest)\n  var md = plugin.md;\n  var pools = new Array(32);\n  for(var i = 0; i < 32; ++i) {\n    pools[i] = md.create();\n  }\n  ctx.pools = pools;\n\n  // entropy pools are written to cyclically, starting at index 0\n  ctx.pool = 0;\n\n  /**\n   * Generates random bytes. The bytes may be generated synchronously or\n   * asynchronously. Web workers must use the asynchronous interface or\n   * else the behavior is undefined.\n   *\n   * @param count the number of random bytes to generate.\n   * @param [callback(err, bytes)] called once the operation completes.\n   *\n   * @return count random bytes as a string.\n   */\n  ctx.generate = function(count, callback) {\n    // do synchronously\n    if(!callback) {\n      return ctx.generateSync(count);\n    }\n\n    // simple generator using counter-based CBC\n    var cipher = ctx.plugin.cipher;\n    var increment = ctx.plugin.increment;\n    var formatKey = ctx.plugin.formatKey;\n    var formatSeed = ctx.plugin.formatSeed;\n    var b = forge.util.createBuffer();\n\n    // paranoid deviation from Fortuna:\n    // reset key for every request to protect previously\n    // generated random bytes should the key be discovered;\n    // there is no 100ms based reseeding because of this\n    // forced reseed for every `generate` call\n    ctx.key = null;\n\n    generate();\n\n    function generate(err) {\n      if(err) {\n        return callback(err);\n      }\n\n      // sufficient bytes generated\n      if(b.length() >= count) {\n        return callback(null, b.getBytes(count));\n      }\n\n      // if amount of data generated is greater than 1 MiB, trigger reseed\n      if(ctx.generated > 0xfffff) {\n        ctx.key = null;\n      }\n\n      if(ctx.key === null) {\n        // prevent stack overflow\n        return forge.util.nextTick(function() {\n          _reseed(generate);\n        });\n      }\n\n      // generate the random bytes\n      var bytes = cipher(ctx.key, ctx.seed);\n      ctx.generated += bytes.length;\n      b.putBytes(bytes);\n\n      // generate bytes for a new key and seed\n      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n\n      forge.util.setImmediate(generate);\n    }\n  };\n\n  /**\n   * Generates random bytes synchronously.\n   *\n   * @param count the number of random bytes to generate.\n   *\n   * @return count random bytes as a string.\n   */\n  ctx.generateSync = function(count) {\n    // simple generator using counter-based CBC\n    var cipher = ctx.plugin.cipher;\n    var increment = ctx.plugin.increment;\n    var formatKey = ctx.plugin.formatKey;\n    var formatSeed = ctx.plugin.formatSeed;\n\n    // paranoid deviation from Fortuna:\n    // reset key for every request to protect previously\n    // generated random bytes should the key be discovered;\n    // there is no 100ms based reseeding because of this\n    // forced reseed for every `generateSync` call\n    ctx.key = null;\n\n    var b = forge.util.createBuffer();\n    while(b.length() < count) {\n      // if amount of data generated is greater than 1 MiB, trigger reseed\n      if(ctx.generated > 0xfffff) {\n        ctx.key = null;\n      }\n\n      if(ctx.key === null) {\n        _reseedSync();\n      }\n\n      // generate the random bytes\n      var bytes = cipher(ctx.key, ctx.seed);\n      ctx.generated += bytes.length;\n      b.putBytes(bytes);\n\n      // generate bytes for a new key and seed\n      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n    }\n\n    return b.getBytes(count);\n  };\n\n  /**\n   * Private function that asynchronously reseeds a generator.\n   *\n   * @param callback(err) called once the operation completes.\n   */\n  function _reseed(callback) {\n    if(ctx.pools[0].messageLength >= 32) {\n      _seed();\n      return callback();\n    }\n    // not enough seed data...\n    var needed = (32 - ctx.pools[0].messageLength) << 5;\n    ctx.seedFile(needed, function(err, bytes) {\n      if(err) {\n        return callback(err);\n      }\n      ctx.collect(bytes);\n      _seed();\n      callback();\n    });\n  }\n\n  /**\n   * Private function that synchronously reseeds a generator.\n   */\n  function _reseedSync() {\n    if(ctx.pools[0].messageLength >= 32) {\n      return _seed();\n    }\n    // not enough seed data...\n    var needed = (32 - ctx.pools[0].messageLength) << 5;\n    ctx.collect(ctx.seedFileSync(needed));\n    _seed();\n  }\n\n  /**\n   * Private function that seeds a generator once enough bytes are available.\n   */\n  function _seed() {\n    // update reseed count\n    ctx.reseeds = (ctx.reseeds === 0xffffffff) ? 0 : ctx.reseeds + 1;\n\n    // goal is to update `key` via:\n    // key = hash(key + s)\n    //   where 's' is all collected entropy from selected pools, then...\n\n    // create a plugin-based message digest\n    var md = ctx.plugin.md.create();\n\n    // consume current key bytes\n    md.update(ctx.keyBytes);\n\n    // digest the entropy of pools whose index k meet the\n    // condition 'n mod 2^k == 0' where n is the number of reseeds\n    var _2powK = 1;\n    for(var k = 0; k < 32; ++k) {\n      if(ctx.reseeds % _2powK === 0) {\n        md.update(ctx.pools[k].digest().getBytes());\n        ctx.pools[k].start();\n      }\n      _2powK = _2powK << 1;\n    }\n\n    // get digest for key bytes\n    ctx.keyBytes = md.digest().getBytes();\n\n    // paranoid deviation from Fortuna:\n    // update `seed` via `seed = hash(key)`\n    // instead of initializing to zero once and only\n    // ever incrementing it\n    md.start();\n    md.update(ctx.keyBytes);\n    var seedBytes = md.digest().getBytes();\n\n    // update state\n    ctx.key = ctx.plugin.formatKey(ctx.keyBytes);\n    ctx.seed = ctx.plugin.formatSeed(seedBytes);\n    ctx.generated = 0;\n  }\n\n  /**\n   * The built-in default seedFile. This seedFile is used when entropy\n   * is needed immediately.\n   *\n   * @param needed the number of bytes that are needed.\n   *\n   * @return the random bytes.\n   */\n  function defaultSeedFile(needed) {\n    // use window.crypto.getRandomValues strong source of entropy if available\n    var getRandomValues = null;\n    var globalScope = forge.util.globalScope;\n    var _crypto = globalScope.crypto || globalScope.msCrypto;\n    if(_crypto && _crypto.getRandomValues) {\n      getRandomValues = function(arr) {\n        return _crypto.getRandomValues(arr);\n      };\n    }\n\n    var b = forge.util.createBuffer();\n    if(getRandomValues) {\n      while(b.length() < needed) {\n        // max byte length is 65536 before QuotaExceededError is thrown\n        // http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues\n        var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);\n        var entropy = new Uint32Array(Math.floor(count));\n        try {\n          getRandomValues(entropy);\n          for(var i = 0; i < entropy.length; ++i) {\n            b.putInt32(entropy[i]);\n          }\n        } catch(e) {\n          /* only ignore QuotaExceededError */\n          if(!(typeof QuotaExceededError !== 'undefined' &&\n            e instanceof QuotaExceededError)) {\n            throw e;\n          }\n        }\n      }\n    }\n\n    // be sad and add some weak random data\n    if(b.length() < needed) {\n      /* Draws from Park-Miller \"minimal standard\" 31 bit PRNG,\n      implemented with David G. Carta's optimization: with 32 bit math\n      and without division (Public Domain). */\n      var hi, lo, next;\n      var seed = Math.floor(Math.random() * 0x010000);\n      while(b.length() < needed) {\n        lo = 16807 * (seed & 0xFFFF);\n        hi = 16807 * (seed >> 16);\n        lo += (hi & 0x7FFF) << 16;\n        lo += hi >> 15;\n        lo = (lo & 0x7FFFFFFF) + (lo >> 31);\n        seed = lo & 0xFFFFFFFF;\n\n        // consume lower 3 bytes of seed\n        for(var i = 0; i < 3; ++i) {\n          // throw in more pseudo random\n          next = seed >>> (i << 3);\n          next ^= Math.floor(Math.random() * 0x0100);\n          b.putByte(next & 0xFF);\n        }\n      }\n    }\n\n    return b.getBytes(needed);\n  }\n  // initialize seed file APIs\n  if(_crypto) {\n    // use nodejs async API\n    ctx.seedFile = function(needed, callback) {\n      _crypto.randomBytes(needed, function(err, bytes) {\n        if(err) {\n          return callback(err);\n        }\n        callback(null, bytes.toString());\n      });\n    };\n    // use nodejs sync API\n    ctx.seedFileSync = function(needed) {\n      return _crypto.randomBytes(needed).toString();\n    };\n  } else {\n    ctx.seedFile = function(needed, callback) {\n      try {\n        callback(null, defaultSeedFile(needed));\n      } catch(e) {\n        callback(e);\n      }\n    };\n    ctx.seedFileSync = defaultSeedFile;\n  }\n\n  /**\n   * Adds entropy to a prng ctx's accumulator.\n   *\n   * @param bytes the bytes of entropy as a string.\n   */\n  ctx.collect = function(bytes) {\n    // iterate over pools distributing entropy cyclically\n    var count = bytes.length;\n    for(var i = 0; i < count; ++i) {\n      ctx.pools[ctx.pool].update(bytes.substr(i, 1));\n      ctx.pool = (ctx.pool === 31) ? 0 : ctx.pool + 1;\n    }\n  };\n\n  /**\n   * Collects an integer of n bits.\n   *\n   * @param i the integer entropy.\n   * @param n the number of bits in the integer.\n   */\n  ctx.collectInt = function(i, n) {\n    var bytes = '';\n    for(var x = 0; x < n; x += 8) {\n      bytes += String.fromCharCode((i >> x) & 0xFF);\n    }\n    ctx.collect(bytes);\n  };\n\n  /**\n   * Registers a Web Worker to receive immediate entropy from the main thread.\n   * This method is required until Web Workers can access the native crypto\n   * API. This method should be called twice for each created worker, once in\n   * the main thread, and once in the worker itself.\n   *\n   * @param worker the worker to register.\n   */\n  ctx.registerWorker = function(worker) {\n    // worker receives random bytes\n    if(worker === self) {\n      ctx.seedFile = function(needed, callback) {\n        function listener(e) {\n          var data = e.data;\n          if(data.forge && data.forge.prng) {\n            self.removeEventListener('message', listener);\n            callback(data.forge.prng.err, data.forge.prng.bytes);\n          }\n        }\n        self.addEventListener('message', listener);\n        self.postMessage({forge: {prng: {needed: needed}}});\n      };\n    } else {\n      // main thread sends random bytes upon request\n      var listener = function(e) {\n        var data = e.data;\n        if(data.forge && data.forge.prng) {\n          ctx.seedFile(data.forge.prng.needed, function(err, bytes) {\n            worker.postMessage({forge: {prng: {err: err, bytes: bytes}}});\n          });\n        }\n      };\n      // TODO: do we need to remove the event listener when the worker dies?\n      worker.addEventListener('message', listener);\n    }\n  };\n\n  return ctx;\n};\n", "/**\n * An API for getting cryptographically-secure random bytes. The bytes are\n * generated using the Fortuna algorithm devised by Bruce Schneier and\n * Niels Ferguson.\n *\n * Getting strong random bytes is not yet easy to do in javascript. The only\n * truish random entropy that can be collected is from the mouse, keyboard, or\n * from timing with respect to page loads, etc. This generator makes a poor\n * attempt at providing random bytes when those sources haven't yet provided\n * enough entropy to initially seed or to reseed the PRNG.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2009-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./aes');\nrequire('./sha256');\nrequire('./prng');\nrequire('./util');\n\n(function() {\n\n// forge.random already defined\nif(forge.random && forge.random.getBytes) {\n  module.exports = forge.random;\n  return;\n}\n\n(function(jQuery) {\n\n// the default prng plugin, uses AES-128\nvar prng_aes = {};\nvar _prng_aes_output = new Array(4);\nvar _prng_aes_buffer = forge.util.createBuffer();\nprng_aes.formatKey = function(key) {\n  // convert the key into 32-bit integers\n  var tmp = forge.util.createBuffer(key);\n  key = new Array(4);\n  key[0] = tmp.getInt32();\n  key[1] = tmp.getInt32();\n  key[2] = tmp.getInt32();\n  key[3] = tmp.getInt32();\n\n  // return the expanded key\n  return forge.aes._expandKey(key, false);\n};\nprng_aes.formatSeed = function(seed) {\n  // convert seed into 32-bit integers\n  var tmp = forge.util.createBuffer(seed);\n  seed = new Array(4);\n  seed[0] = tmp.getInt32();\n  seed[1] = tmp.getInt32();\n  seed[2] = tmp.getInt32();\n  seed[3] = tmp.getInt32();\n  return seed;\n};\nprng_aes.cipher = function(key, seed) {\n  forge.aes._updateBlock(key, seed, _prng_aes_output, false);\n  _prng_aes_buffer.putInt32(_prng_aes_output[0]);\n  _prng_aes_buffer.putInt32(_prng_aes_output[1]);\n  _prng_aes_buffer.putInt32(_prng_aes_output[2]);\n  _prng_aes_buffer.putInt32(_prng_aes_output[3]);\n  return _prng_aes_buffer.getBytes();\n};\nprng_aes.increment = function(seed) {\n  // FIXME: do we care about carry or signed issues?\n  ++seed[3];\n  return seed;\n};\nprng_aes.md = forge.md.sha256;\n\n/**\n * Creates a new PRNG.\n */\nfunction spawnPrng() {\n  var ctx = forge.prng.create(prng_aes);\n\n  /**\n   * Gets random bytes. If a native secure crypto API is unavailable, this\n   * method tries to make the bytes more unpredictable by drawing from data that\n   * can be collected from the user of the browser, eg: mouse movement.\n   *\n   * If a callback is given, this method will be called asynchronously.\n   *\n   * @param count the number of random bytes to get.\n   * @param [callback(err, bytes)] called once the operation completes.\n   *\n   * @return the random bytes in a string.\n   */\n  ctx.getBytes = function(count, callback) {\n    return ctx.generate(count, callback);\n  };\n\n  /**\n   * Gets random bytes asynchronously. If a native secure crypto API is\n   * unavailable, this method tries to make the bytes more unpredictable by\n   * drawing from data that can be collected from the user of the browser,\n   * eg: mouse movement.\n   *\n   * @param count the number of random bytes to get.\n   *\n   * @return the random bytes in a string.\n   */\n  ctx.getBytesSync = function(count) {\n    return ctx.generate(count);\n  };\n\n  return ctx;\n}\n\n// create default prng context\nvar _ctx = spawnPrng();\n\n// add other sources of entropy only if window.crypto.getRandomValues is not\n// available -- otherwise this source will be automatically used by the prng\nvar getRandomValues = null;\nvar globalScope = forge.util.globalScope;\nvar _crypto = globalScope.crypto || globalScope.msCrypto;\nif(_crypto && _crypto.getRandomValues) {\n  getRandomValues = function(arr) {\n    return _crypto.getRandomValues(arr);\n  };\n}\n\nif(forge.options.usePureJavaScript ||\n  (!forge.util.isNodejs && !getRandomValues)) {\n  // if this is a web worker, do not use weak entropy, instead register to\n  // receive strong entropy asynchronously from the main thread\n  if(typeof window === 'undefined' || window.document === undefined) {\n    // FIXME:\n  }\n\n  // get load time entropy\n  _ctx.collectInt(+new Date(), 32);\n\n  // add some entropy from navigator object\n  if(typeof(navigator) !== 'undefined') {\n    var _navBytes = '';\n    for(var key in navigator) {\n      try {\n        if(typeof(navigator[key]) == 'string') {\n          _navBytes += navigator[key];\n        }\n      } catch(e) {\n        /* Some navigator keys might not be accessible, e.g. the geolocation\n          attribute throws an exception if touched in Mozilla chrome://\n          context.\n\n          Silently ignore this and just don't use this as a source of\n          entropy. */\n      }\n    }\n    _ctx.collect(_navBytes);\n    _navBytes = null;\n  }\n\n  // add mouse and keyboard collectors if jquery is available\n  if(jQuery) {\n    // set up mouse entropy capture\n    jQuery().mousemove(function(e) {\n      // add mouse coords\n      _ctx.collectInt(e.clientX, 16);\n      _ctx.collectInt(e.clientY, 16);\n    });\n\n    // set up keyboard entropy capture\n    jQuery().keypress(function(e) {\n      _ctx.collectInt(e.charCode, 8);\n    });\n  }\n}\n\n/* Random API */\nif(!forge.random) {\n  forge.random = _ctx;\n} else {\n  // extend forge.random with _ctx\n  for(var key in _ctx) {\n    forge.random[key] = _ctx[key];\n  }\n}\n\n// expose spawn PRNG\nforge.random.createInstance = spawnPrng;\n\nmodule.exports = forge.random;\n\n})(typeof(jQuery) !== 'undefined' ? jQuery : null);\n\n})();\n", "/**\n * Secure Hash Algorithm with 160-bit digest (SHA-1) implementation.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2015 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./md');\nrequire('./util');\n\nvar sha1 = module.exports = forge.sha1 = forge.sha1 || {};\nforge.md.sha1 = forge.md.algorithms.sha1 = sha1;\n\n/**\n * Creates a SHA-1 message digest object.\n *\n * @return a message digest object.\n */\nsha1.create = function() {\n  // do initialization as necessary\n  if(!_initialized) {\n    _init();\n  }\n\n  // SHA-1 state contains five 32-bit integers\n  var _state = null;\n\n  // input buffer\n  var _input = forge.util.createBuffer();\n\n  // used for word storage\n  var _w = new Array(80);\n\n  // message digest object\n  var md = {\n    algorithm: 'sha1',\n    blockLength: 64,\n    digestLength: 20,\n    // 56-bit length of message so far (does not including padding)\n    messageLength: 0,\n    // true message length\n    fullMessageLength: null,\n    // size of message length in bytes\n    messageLengthSize: 8\n  };\n\n  /**\n   * Starts the digest.\n   *\n   * @return this digest object.\n   */\n  md.start = function() {\n    // up to 56-bit message length for convenience\n    md.messageLength = 0;\n\n    // full message length (set md.messageLength64 for backwards-compatibility)\n    md.fullMessageLength = md.messageLength64 = [];\n    var int32s = md.messageLengthSize / 4;\n    for(var i = 0; i < int32s; ++i) {\n      md.fullMessageLength.push(0);\n    }\n    _input = forge.util.createBuffer();\n    _state = {\n      h0: 0x67452301,\n      h1: 0xEFCDAB89,\n      h2: 0x98BADCFE,\n      h3: 0x10325476,\n      h4: 0xC3D2E1F0\n    };\n    return md;\n  };\n  // start digest automatically for first time\n  md.start();\n\n  /**\n   * Updates the digest with the given message input. The given input can\n   * treated as raw input (no encoding will be applied) or an encoding of\n   * 'utf8' maybe given to encode the input using UTF-8.\n   *\n   * @param msg the message input to update with.\n   * @param encoding the encoding to use (default: 'raw', other: 'utf8').\n   *\n   * @return this digest object.\n   */\n  md.update = function(msg, encoding) {\n    if(encoding === 'utf8') {\n      msg = forge.util.encodeUtf8(msg);\n    }\n\n    // update message length\n    var len = msg.length;\n    md.messageLength += len;\n    len = [(len / 0x100000000) >>> 0, len >>> 0];\n    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {\n      md.fullMessageLength[i] += len[1];\n      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) >>> 0);\n      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\n      len[0] = ((len[1] / 0x100000000) >>> 0);\n    }\n\n    // add bytes to input buffer\n    _input.putBytes(msg);\n\n    // process bytes\n    _update(_state, _w, _input);\n\n    // compact input buffer every 2K or if empty\n    if(_input.read > 2048 || _input.length() === 0) {\n      _input.compact();\n    }\n\n    return md;\n  };\n\n  /**\n   * Produces the digest.\n   *\n   * @return a byte buffer containing the digest value.\n   */\n  md.digest = function() {\n    /* Note: Here we copy the remaining bytes in the input buffer and\n    add the appropriate SHA-1 padding. Then we do the final update\n    on a copy of the state so that if the user wants to get\n    intermediate digests they can do so. */\n\n    /* Determine the number of bytes that must be added to the message\n    to ensure its length is congruent to 448 mod 512. In other words,\n    the data to be digested must be a multiple of 512 bits (or 128 bytes).\n    This data includes the message, some padding, and the length of the\n    message. Since the length of the message will be encoded as 8 bytes (64\n    bits), that means that the last segment of the data must have 56 bytes\n    (448 bits) of message and padding. Therefore, the length of the message\n    plus the padding must be congruent to 448 mod 512 because\n    512 - 128 = 448.\n\n    In order to fill up the message length it must be filled with\n    padding that begins with 1 bit followed by all 0 bits. Padding\n    must *always* be present, so if the message length is already\n    congruent to 448 mod 512, then 512 padding bits must be added. */\n\n    var finalBlock = forge.util.createBuffer();\n    finalBlock.putBytes(_input.bytes());\n\n    // compute remaining size to be digested (include message length size)\n    var remaining = (\n      md.fullMessageLength[md.fullMessageLength.length - 1] +\n      md.messageLengthSize);\n\n    // add padding for overflow blockSize - overflow\n    // _padding starts with 1 byte with first bit is set (byte value 128), then\n    // there may be up to (blockSize - 1) other pad bytes\n    var overflow = remaining & (md.blockLength - 1);\n    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\n\n    // serialize message length in bits in big-endian order; since length\n    // is stored in bytes we multiply by 8 and add carry from next int\n    var next, carry;\n    var bits = md.fullMessageLength[0] * 8;\n    for(var i = 0; i < md.fullMessageLength.length - 1; ++i) {\n      next = md.fullMessageLength[i + 1] * 8;\n      carry = (next / 0x100000000) >>> 0;\n      bits += carry;\n      finalBlock.putInt32(bits >>> 0);\n      bits = next >>> 0;\n    }\n    finalBlock.putInt32(bits);\n\n    var s2 = {\n      h0: _state.h0,\n      h1: _state.h1,\n      h2: _state.h2,\n      h3: _state.h3,\n      h4: _state.h4\n    };\n    _update(s2, _w, finalBlock);\n    var rval = forge.util.createBuffer();\n    rval.putInt32(s2.h0);\n    rval.putInt32(s2.h1);\n    rval.putInt32(s2.h2);\n    rval.putInt32(s2.h3);\n    rval.putInt32(s2.h4);\n    return rval;\n  };\n\n  return md;\n};\n\n// sha-1 padding bytes not initialized yet\nvar _padding = null;\nvar _initialized = false;\n\n/**\n * Initializes the constant tables.\n */\nfunction _init() {\n  // create padding\n  _padding = String.fromCharCode(128);\n  _padding += forge.util.fillString(String.fromCharCode(0x00), 64);\n\n  // now initialized\n  _initialized = true;\n}\n\n/**\n * Updates a SHA-1 state with the given byte buffer.\n *\n * @param s the SHA-1 state to update.\n * @param w the array to use to store words.\n * @param bytes the byte buffer to update with.\n */\nfunction _update(s, w, bytes) {\n  // consume 512 bit (64 byte) chunks\n  var t, a, b, c, d, e, f, i;\n  var len = bytes.length();\n  while(len >= 64) {\n    // the w array will be populated with sixteen 32-bit big-endian words\n    // and then extended into 80 32-bit words according to SHA-1 algorithm\n    // and for 32-79 using Max Locktyukhin's optimization\n\n    // initialize hash value for this chunk\n    a = s.h0;\n    b = s.h1;\n    c = s.h2;\n    d = s.h3;\n    e = s.h4;\n\n    // round 1\n    for(i = 0; i < 16; ++i) {\n      t = bytes.getInt32();\n      w[i] = t;\n      f = d ^ (b & (c ^ d));\n      t = ((a << 5) | (a >>> 27)) + f + e + 0x5A827999 + t;\n      e = d;\n      d = c;\n      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n      c = ((b << 30) | (b >>> 2)) >>> 0;\n      b = a;\n      a = t;\n    }\n    for(; i < 20; ++i) {\n      t = (w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);\n      t = (t << 1) | (t >>> 31);\n      w[i] = t;\n      f = d ^ (b & (c ^ d));\n      t = ((a << 5) | (a >>> 27)) + f + e + 0x5A827999 + t;\n      e = d;\n      d = c;\n      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n      c = ((b << 30) | (b >>> 2)) >>> 0;\n      b = a;\n      a = t;\n    }\n    // round 2\n    for(; i < 32; ++i) {\n      t = (w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);\n      t = (t << 1) | (t >>> 31);\n      w[i] = t;\n      f = b ^ c ^ d;\n      t = ((a << 5) | (a >>> 27)) + f + e + 0x6ED9EBA1 + t;\n      e = d;\n      d = c;\n      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n      c = ((b << 30) | (b >>> 2)) >>> 0;\n      b = a;\n      a = t;\n    }\n    for(; i < 40; ++i) {\n      t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);\n      t = (t << 2) | (t >>> 30);\n      w[i] = t;\n      f = b ^ c ^ d;\n      t = ((a << 5) | (a >>> 27)) + f + e + 0x6ED9EBA1 + t;\n      e = d;\n      d = c;\n      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n      c = ((b << 30) | (b >>> 2)) >>> 0;\n      b = a;\n      a = t;\n    }\n    // round 3\n    for(; i < 60; ++i) {\n      t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);\n      t = (t << 2) | (t >>> 30);\n      w[i] = t;\n      f = (b & c) | (d & (b ^ c));\n      t = ((a << 5) | (a >>> 27)) + f + e + 0x8F1BBCDC + t;\n      e = d;\n      d = c;\n      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n      c = ((b << 30) | (b >>> 2)) >>> 0;\n      b = a;\n      a = t;\n    }\n    // round 4\n    for(; i < 80; ++i) {\n      t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);\n      t = (t << 2) | (t >>> 30);\n      w[i] = t;\n      f = b ^ c ^ d;\n      t = ((a << 5) | (a >>> 27)) + f + e + 0xCA62C1D6 + t;\n      e = d;\n      d = c;\n      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug\n      c = ((b << 30) | (b >>> 2)) >>> 0;\n      b = a;\n      a = t;\n    }\n\n    // update hash state\n    s.h0 = (s.h0 + a) | 0;\n    s.h1 = (s.h1 + b) | 0;\n    s.h2 = (s.h2 + c) | 0;\n    s.h3 = (s.h3 + d) | 0;\n    s.h4 = (s.h4 + e) | 0;\n\n    len -= 64;\n  }\n}\n", "/**\n * Partial implementation of PKCS#1 v2.2: RSA-OEAP\n *\n * Modified but based on the following MIT and BSD licensed code:\n *\n * https://github.com/kjur/jsjws/blob/master/rsa.js:\n *\n * The 'jsjws'(JSON Web Signature JavaScript Library) License\n *\n * Copyright (c) 2012 Kenji Urushima\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * http://webrsa.cvs.sourceforge.net/viewvc/webrsa/Client/RSAES-OAEP.js?content-type=text%2Fplain:\n *\n * RSAES-OAEP.js\n * $Id: RSAES-OAEP.js,v 1.1.1.1 2003/03/19 15:37:20 ellispritchard Exp $\n * JavaScript Implementation of PKCS #1 v2.1 RSA CRYPTOGRAPHY STANDARD (RSA Laboratories, June 14, 2002)\n * Copyright (C) Ellis Pritchard, Guardian Unlimited 2003.\n * Contact: ellis@nukinetics.com\n * Distributed under the BSD License.\n *\n * Official documentation: http://www.rsa.com/rsalabs/node.asp?id=2125\n *\n * @author Evan Jones (http://evanjones.ca/)\n * @author Dave Longley\n *\n * Copyright (c) 2013-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\nrequire('./random');\nrequire('./sha1');\n\n// shortcut for PKCS#1 API\nvar pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {};\n\n/**\n * Encode the given RSAES-OAEP message (M) using key, with optional label (L)\n * and seed.\n *\n * This method does not perform RSA encryption, it only encodes the message\n * using RSAES-OAEP.\n *\n * @param key the RSA key to use.\n * @param message the message to encode.\n * @param options the options to use:\n *          label an optional label to use.\n *          seed the seed to use.\n *          md the message digest object to use, undefined for SHA-1.\n *          mgf1 optional mgf1 parameters:\n *            md the message digest object to use for MGF1.\n *\n * @return the encoded message bytes.\n */\npkcs1.encode_rsa_oaep = function(key, message, options) {\n  // parse arguments\n  var label;\n  var seed;\n  var md;\n  var mgf1Md;\n  // legacy args (label, seed, md)\n  if(typeof options === 'string') {\n    label = options;\n    seed = arguments[3] || undefined;\n    md = arguments[4] || undefined;\n  } else if(options) {\n    label = options.label || undefined;\n    seed = options.seed || undefined;\n    md = options.md || undefined;\n    if(options.mgf1 && options.mgf1.md) {\n      mgf1Md = options.mgf1.md;\n    }\n  }\n\n  // default OAEP to SHA-1 message digest\n  if(!md) {\n    md = forge.md.sha1.create();\n  } else {\n    md.start();\n  }\n\n  // default MGF-1 to same as OAEP\n  if(!mgf1Md) {\n    mgf1Md = md;\n  }\n\n  // compute length in bytes and check output\n  var keyLength = Math.ceil(key.n.bitLength() / 8);\n  var maxLength = keyLength - 2 * md.digestLength - 2;\n  if(message.length > maxLength) {\n    var error = new Error('RSAES-OAEP input message length is too long.');\n    error.length = message.length;\n    error.maxLength = maxLength;\n    throw error;\n  }\n\n  if(!label) {\n    label = '';\n  }\n  md.update(label, 'raw');\n  var lHash = md.digest();\n\n  var PS = '';\n  var PS_length = maxLength - message.length;\n  for(var i = 0; i < PS_length; i++) {\n    PS += '\\x00';\n  }\n\n  var DB = lHash.getBytes() + PS + '\\x01' + message;\n\n  if(!seed) {\n    seed = forge.random.getBytes(md.digestLength);\n  } else if(seed.length !== md.digestLength) {\n    var error = new Error('Invalid RSAES-OAEP seed. The seed length must ' +\n      'match the digest length.');\n    error.seedLength = seed.length;\n    error.digestLength = md.digestLength;\n    throw error;\n  }\n\n  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);\n  var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);\n\n  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);\n  var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);\n\n  // return encoded message\n  return '\\x00' + maskedSeed + maskedDB;\n};\n\n/**\n * Decode the given RSAES-OAEP encoded message (EM) using key, with optional\n * label (L).\n *\n * This method does not perform RSA decryption, it only decodes the message\n * using RSAES-OAEP.\n *\n * @param key the RSA key to use.\n * @param em the encoded message to decode.\n * @param options the options to use:\n *          label an optional label to use.\n *          md the message digest object to use for OAEP, undefined for SHA-1.\n *          mgf1 optional mgf1 parameters:\n *            md the message digest object to use for MGF1.\n *\n * @return the decoded message bytes.\n */\npkcs1.decode_rsa_oaep = function(key, em, options) {\n  // parse args\n  var label;\n  var md;\n  var mgf1Md;\n  // legacy args\n  if(typeof options === 'string') {\n    label = options;\n    md = arguments[3] || undefined;\n  } else if(options) {\n    label = options.label || undefined;\n    md = options.md || undefined;\n    if(options.mgf1 && options.mgf1.md) {\n      mgf1Md = options.mgf1.md;\n    }\n  }\n\n  // compute length in bytes\n  var keyLength = Math.ceil(key.n.bitLength() / 8);\n\n  if(em.length !== keyLength) {\n    var error = new Error('RSAES-OAEP encoded message length is invalid.');\n    error.length = em.length;\n    error.expectedLength = keyLength;\n    throw error;\n  }\n\n  // default OAEP to SHA-1 message digest\n  if(md === undefined) {\n    md = forge.md.sha1.create();\n  } else {\n    md.start();\n  }\n\n  // default MGF-1 to same as OAEP\n  if(!mgf1Md) {\n    mgf1Md = md;\n  }\n\n  if(keyLength < 2 * md.digestLength + 2) {\n    throw new Error('RSAES-OAEP key is too short for the hash function.');\n  }\n\n  if(!label) {\n    label = '';\n  }\n  md.update(label, 'raw');\n  var lHash = md.digest().getBytes();\n\n  // split the message into its parts\n  var y = em.charAt(0);\n  var maskedSeed = em.substring(1, md.digestLength + 1);\n  var maskedDB = em.substring(1 + md.digestLength);\n\n  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);\n  var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);\n\n  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);\n  var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);\n\n  var lHashPrime = db.substring(0, md.digestLength);\n\n  // constant time check that all values match what is expected\n  var error = (y !== '\\x00');\n\n  // constant time check lHash vs lHashPrime\n  for(var i = 0; i < md.digestLength; ++i) {\n    error |= (lHash.charAt(i) !== lHashPrime.charAt(i));\n  }\n\n  // \"constant time\" find the 0x1 byte separating the padding (zeros) from the\n  // message\n  // TODO: It must be possible to do this in a better/smarter way?\n  var in_ps = 1;\n  var index = md.digestLength;\n  for(var j = md.digestLength; j < db.length; j++) {\n    var code = db.charCodeAt(j);\n\n    var is_0 = (code & 0x1) ^ 0x1;\n\n    // non-zero if not 0 or 1 in the ps section\n    var error_mask = in_ps ? 0xfffe : 0x0000;\n    error |= (code & error_mask);\n\n    // latch in_ps to zero after we find 0x1\n    in_ps = in_ps & is_0;\n    index += in_ps;\n  }\n\n  if(error || db.charCodeAt(index) !== 0x1) {\n    throw new Error('Invalid RSAES-OAEP padding.');\n  }\n\n  return db.substring(index + 1);\n};\n\nfunction rsa_mgf1(seed, maskLength, hash) {\n  // default to SHA-1 message digest\n  if(!hash) {\n    hash = forge.md.sha1.create();\n  }\n  var t = '';\n  var count = Math.ceil(maskLength / hash.digestLength);\n  for(var i = 0; i < count; ++i) {\n    var c = String.fromCharCode(\n      (i >> 24) & 0xFF, (i >> 16) & 0xFF, (i >> 8) & 0xFF, i & 0xFF);\n    hash.start();\n    hash.update(seed + c);\n    t += hash.digest().getBytes();\n  }\n  return t.substring(0, maskLength);\n}\n", "/**\n * Prime number generation API.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\nrequire('./jsbn');\nrequire('./random');\n\n(function() {\n\n// forge.prime already defined\nif(forge.prime) {\n  module.exports = forge.prime;\n  return;\n}\n\n/* PRIME API */\nvar prime = module.exports = forge.prime = forge.prime || {};\n\nvar BigInteger = forge.jsbn.BigInteger;\n\n// primes are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29\nvar GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];\nvar THIRTY = new BigInteger(null);\nTHIRTY.fromInt(30);\nvar op_or = function(x, y) {return x|y;};\n\n/**\n * Generates a random probable prime with the given number of bits.\n *\n * Alternative algorithms can be specified by name as a string or as an\n * object with custom options like so:\n *\n * {\n *   name: 'PRIMEINC',\n *   options: {\n *     maxBlockTime: <the maximum amount of time to block the main\n *       thread before allowing I/O other JS to run>,\n *     millerRabinTests: <the number of miller-rabin tests to run>,\n *     workerScript: <the worker script URL>,\n *     workers: <the number of web workers (if supported) to use,\n *       -1 to use estimated cores minus one>.\n *     workLoad: the size of the work load, ie: number of possible prime\n *       numbers for each web worker to check per work assignment,\n *       (default: 100).\n *   }\n * }\n *\n * @param bits the number of bits for the prime number.\n * @param options the options to use.\n *          [algorithm] the algorithm to use (default: 'PRIMEINC').\n *          [prng] a custom crypto-secure pseudo-random number generator to use,\n *            that must define \"getBytesSync\".\n *\n * @return callback(err, num) called once the operation completes.\n */\nprime.generateProbablePrime = function(bits, options, callback) {\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n\n  // default to PRIMEINC algorithm\n  var algorithm = options.algorithm || 'PRIMEINC';\n  if(typeof algorithm === 'string') {\n    algorithm = {name: algorithm};\n  }\n  algorithm.options = algorithm.options || {};\n\n  // create prng with api that matches BigInteger secure random\n  var prng = options.prng || forge.random;\n  var rng = {\n    // x is an array to fill with bytes\n    nextBytes: function(x) {\n      var b = prng.getBytesSync(x.length);\n      for(var i = 0; i < x.length; ++i) {\n        x[i] = b.charCodeAt(i);\n      }\n    }\n  };\n\n  if(algorithm.name === 'PRIMEINC') {\n    return primeincFindPrime(bits, rng, algorithm.options, callback);\n  }\n\n  throw new Error('Invalid prime generation algorithm: ' + algorithm.name);\n};\n\nfunction primeincFindPrime(bits, rng, options, callback) {\n  if('workers' in options) {\n    return primeincFindPrimeWithWorkers(bits, rng, options, callback);\n  }\n  return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\n}\n\nfunction primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {\n  // initialize random number\n  var num = generateRandom(bits, rng);\n\n  /* Note: All primes are of the form 30k+i for i < 30 and gcd(30, i)=1. The\n  number we are given is always aligned at 30k + 1. Each time the number is\n  determined not to be prime we add to get to the next 'i', eg: if the number\n  was at 30k + 1 we add 6. */\n  var deltaIdx = 0;\n\n  // get required number of MR tests\n  var mrTests = getMillerRabinTests(num.bitLength());\n  if('millerRabinTests' in options) {\n    mrTests = options.millerRabinTests;\n  }\n\n  // find prime nearest to 'num' for maxBlockTime ms\n  // 10 ms gives 5ms of leeway for other calculations before dropping\n  // below 60fps (1000/60 == 16.67), but in reality, the number will\n  // likely be higher due to an 'atomic' big int modPow\n  var maxBlockTime = 10;\n  if('maxBlockTime' in options) {\n    maxBlockTime = options.maxBlockTime;\n  }\n\n  _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\n}\n\nfunction _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {\n  var start = +new Date();\n  do {\n    // overflow, regenerate random number\n    if(num.bitLength() > bits) {\n      num = generateRandom(bits, rng);\n    }\n    // do primality test\n    if(num.isProbablePrime(mrTests)) {\n      return callback(null, num);\n    }\n    // get next potential prime\n    num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);\n  } while(maxBlockTime < 0 || (+new Date() - start < maxBlockTime));\n\n  // keep trying later\n  forge.util.setImmediate(function() {\n    _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);\n  });\n}\n\n// NOTE: This algorithm is indeterminate in nature because workers\n// run in parallel looking at different segments of numbers. Even if this\n// algorithm is run twice with the same input from a predictable RNG, it\n// may produce different outputs.\nfunction primeincFindPrimeWithWorkers(bits, rng, options, callback) {\n  // web workers unavailable\n  if(typeof Worker === 'undefined') {\n    return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);\n  }\n\n  // initialize random number\n  var num = generateRandom(bits, rng);\n\n  // use web workers to generate keys\n  var numWorkers = options.workers;\n  var workLoad = options.workLoad || 100;\n  var range = workLoad * 30 / 8;\n  var workerScript = options.workerScript || 'forge/prime.worker.js';\n  if(numWorkers === -1) {\n    return forge.util.estimateCores(function(err, cores) {\n      if(err) {\n        // default to 2\n        cores = 2;\n      }\n      numWorkers = cores - 1;\n      generate();\n    });\n  }\n  generate();\n\n  function generate() {\n    // require at least 1 worker\n    numWorkers = Math.max(1, numWorkers);\n\n    // TODO: consider optimizing by starting workers outside getPrime() ...\n    // note that in order to clean up they will have to be made internally\n    // asynchronous which may actually be slower\n\n    // start workers immediately\n    var workers = [];\n    for(var i = 0; i < numWorkers; ++i) {\n      // FIXME: fix path or use blob URLs\n      workers[i] = new Worker(workerScript);\n    }\n    var running = numWorkers;\n\n    // listen for requests from workers and assign ranges to find prime\n    for(var i = 0; i < numWorkers; ++i) {\n      workers[i].addEventListener('message', workerMessage);\n    }\n\n    /* Note: The distribution of random numbers is unknown. Therefore, each\n    web worker is continuously allocated a range of numbers to check for a\n    random number until one is found.\n\n    Every 30 numbers will be checked just 8 times, because prime numbers\n    have the form:\n\n    30k+i, for i < 30 and gcd(30, i)=1 (there are 8 values of i for this)\n\n    Therefore, if we want a web worker to run N checks before asking for\n    a new range of numbers, each range must contain N*30/8 numbers.\n\n    For 100 checks (workLoad), this is a range of 375. */\n\n    var found = false;\n    function workerMessage(e) {\n      // ignore message, prime already found\n      if(found) {\n        return;\n      }\n\n      --running;\n      var data = e.data;\n      if(data.found) {\n        // terminate all workers\n        for(var i = 0; i < workers.length; ++i) {\n          workers[i].terminate();\n        }\n        found = true;\n        return callback(null, new BigInteger(data.prime, 16));\n      }\n\n      // overflow, regenerate random number\n      if(num.bitLength() > bits) {\n        num = generateRandom(bits, rng);\n      }\n\n      // assign new range to check\n      var hex = num.toString(16);\n\n      // start prime search\n      e.target.postMessage({\n        hex: hex,\n        workLoad: workLoad\n      });\n\n      num.dAddOffset(range, 0);\n    }\n  }\n}\n\n/**\n * Generates a random number using the given number of bits and RNG.\n *\n * @param bits the number of bits for the number.\n * @param rng the random number generator to use.\n *\n * @return the random number.\n */\nfunction generateRandom(bits, rng) {\n  var num = new BigInteger(bits, rng);\n  // force MSB set\n  var bits1 = bits - 1;\n  if(!num.testBit(bits1)) {\n    num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);\n  }\n  // align number on 30k+1 boundary\n  num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);\n  return num;\n}\n\n/**\n * Returns the required number of Miller-Rabin tests to generate a\n * prime with an error probability of (1/2)^80.\n *\n * See Handbook of Applied Cryptography Chapter 4, Table 4.4.\n *\n * @param bits the bit size.\n *\n * @return the required number of iterations.\n */\nfunction getMillerRabinTests(bits) {\n  if(bits <= 100) return 27;\n  if(bits <= 150) return 18;\n  if(bits <= 200) return 15;\n  if(bits <= 250) return 12;\n  if(bits <= 300) return 9;\n  if(bits <= 350) return 8;\n  if(bits <= 400) return 7;\n  if(bits <= 500) return 6;\n  if(bits <= 600) return 5;\n  if(bits <= 800) return 4;\n  if(bits <= 1250) return 3;\n  return 2;\n}\n\n})();\n", "/**\n * Javascript implementation of basic RSA algorithms.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n *\n * The only algorithm currently supported for PKI is RSA.\n *\n * An RSA key is often stored in ASN.1 DER format. The SubjectPublicKeyInfo\n * ASN.1 structure is composed of an algorithm of type AlgorithmIdentifier\n * and a subjectPublicKey of type bit string.\n *\n * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\n * for the algorithm, if any. In the case of RSA, there aren't any.\n *\n * SubjectPublicKeyInfo ::= SEQUENCE {\n *   algorithm AlgorithmIdentifier,\n *   subjectPublicKey BIT STRING\n * }\n *\n * AlgorithmIdentifer ::= SEQUENCE {\n *   algorithm OBJECT IDENTIFIER,\n *   parameters ANY DEFINED BY algorithm OPTIONAL\n * }\n *\n * For an RSA public key, the subjectPublicKey is:\n *\n * RSAPublicKey ::= SEQUENCE {\n *   modulus            INTEGER,    -- n\n *   publicExponent     INTEGER     -- e\n * }\n *\n * PrivateKeyInfo ::= SEQUENCE {\n *   version                   Version,\n *   privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,\n *   privateKey                PrivateKey,\n *   attributes           [0]  IMPLICIT Attributes OPTIONAL\n * }\n *\n * Version ::= INTEGER\n * PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier\n * PrivateKey ::= OCTET STRING\n * Attributes ::= SET OF Attribute\n *\n * An RSA private key as the following structure:\n *\n * RSAPrivateKey ::= SEQUENCE {\n *   version Version,\n *   modulus INTEGER, -- n\n *   publicExponent INTEGER, -- e\n *   privateExponent INTEGER, -- d\n *   prime1 INTEGER, -- p\n *   prime2 INTEGER, -- q\n *   exponent1 INTEGER, -- d mod (p-1)\n *   exponent2 INTEGER, -- d mod (q-1)\n *   coefficient INTEGER -- (inverse of q) mod p\n * }\n *\n * Version ::= INTEGER\n *\n * The OID for the RSA key algorithm is: 1.2.840.113549.1.1.1\n */\nvar forge = require('./forge');\nrequire('./asn1');\nrequire('./jsbn');\nrequire('./oids');\nrequire('./pkcs1');\nrequire('./prime');\nrequire('./random');\nrequire('./util');\n\nif(typeof BigInteger === 'undefined') {\n  var BigInteger = forge.jsbn.BigInteger;\n}\n\nvar _crypto = forge.util.isNodejs ? require('crypto') : null;\n\n// shortcut for asn.1 API\nvar asn1 = forge.asn1;\n\n// shortcut for util API\nvar util = forge.util;\n\n/*\n * RSA encryption and decryption, see RFC 2313.\n */\nforge.pki = forge.pki || {};\nmodule.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};\nvar pki = forge.pki;\n\n// for finding primes, which are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29\nvar GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];\n\n// validator for a PrivateKeyInfo structure\nvar privateKeyValidator = {\n  // PrivateKeyInfo\n  name: 'PrivateKeyInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    // Version (INTEGER)\n    name: 'PrivateKeyInfo.version',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyVersion'\n  }, {\n    // privateKeyAlgorithm\n    name: 'PrivateKeyInfo.privateKeyAlgorithm',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      name: 'AlgorithmIdentifier.algorithm',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OID,\n      constructed: false,\n      capture: 'privateKeyOid'\n    }]\n  }, {\n    // PrivateKey\n    name: 'PrivateKeyInfo',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OCTETSTRING,\n    constructed: false,\n    capture: 'privateKey'\n  }]\n};\n\n// validator for an RSA private key\nvar rsaPrivateKeyValidator = {\n  // RSAPrivateKey\n  name: 'RSAPrivateKey',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    // Version (INTEGER)\n    name: 'RSAPrivateKey.version',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyVersion'\n  }, {\n    // modulus (n)\n    name: 'RSAPrivateKey.modulus',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyModulus'\n  }, {\n    // publicExponent (e)\n    name: 'RSAPrivateKey.publicExponent',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyPublicExponent'\n  }, {\n    // privateExponent (d)\n    name: 'RSAPrivateKey.privateExponent',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyPrivateExponent'\n  }, {\n    // prime1 (p)\n    name: 'RSAPrivateKey.prime1',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyPrime1'\n  }, {\n    // prime2 (q)\n    name: 'RSAPrivateKey.prime2',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyPrime2'\n  }, {\n    // exponent1 (d mod (p-1))\n    name: 'RSAPrivateKey.exponent1',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyExponent1'\n  }, {\n    // exponent2 (d mod (q-1))\n    name: 'RSAPrivateKey.exponent2',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyExponent2'\n  }, {\n    // coefficient ((inverse of q) mod p)\n    name: 'RSAPrivateKey.coefficient',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyCoefficient'\n  }]\n};\n\n// validator for an RSA public key\nvar rsaPublicKeyValidator = {\n  // RSAPublicKey\n  name: 'RSAPublicKey',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    // modulus (n)\n    name: 'RSAPublicKey.modulus',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'publicKeyModulus'\n  }, {\n    // publicExponent (e)\n    name: 'RSAPublicKey.exponent',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'publicKeyExponent'\n  }]\n};\n\n// validator for an SubjectPublicKeyInfo structure\n// Note: Currently only works with an RSA public key\nvar publicKeyValidator = forge.pki.rsa.publicKeyValidator = {\n  name: 'SubjectPublicKeyInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  captureAsn1: 'subjectPublicKeyInfo',\n  value: [{\n    name: 'SubjectPublicKeyInfo.AlgorithmIdentifier',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      name: 'AlgorithmIdentifier.algorithm',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OID,\n      constructed: false,\n      capture: 'publicKeyOid'\n    }]\n  }, {\n    // subjectPublicKey\n    name: 'SubjectPublicKeyInfo.subjectPublicKey',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.BITSTRING,\n    constructed: false,\n    value: [{\n      // RSAPublicKey\n      name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      optional: true,\n      captureAsn1: 'rsaPublicKey'\n    }]\n  }]\n};\n\n// validator for a DigestInfo structure\nvar digestInfoValidator = {\n  name: 'DigestInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'DigestInfo.DigestAlgorithm',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      name: 'DigestInfo.DigestAlgorithm.algorithmIdentifier',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OID,\n      constructed: false,\n      capture: 'algorithmIdentifier'\n    }, {\n      // NULL paramters\n      name: 'DigestInfo.DigestAlgorithm.parameters',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.NULL,\n      // captured only to check existence for md2 and md5\n      capture: 'parameters',\n      optional: true,\n      constructed: false\n    }]\n  }, {\n    // digest\n    name: 'DigestInfo.digest',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OCTETSTRING,\n    constructed: false,\n    capture: 'digest'\n  }]\n};\n\n/**\n * Wrap digest in DigestInfo object.\n *\n * This function implements EMSA-PKCS1-v1_5-ENCODE as per RFC 3447.\n *\n * DigestInfo ::= SEQUENCE {\n *   digestAlgorithm DigestAlgorithmIdentifier,\n *   digest Digest\n * }\n *\n * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\n * Digest ::= OCTET STRING\n *\n * @param md the message digest object with the hash to sign.\n *\n * @return the encoded message (ready for RSA encrytion)\n */\nvar emsaPkcs1v15encode = function(md) {\n  // get the oid for the algorithm\n  var oid;\n  if(md.algorithm in pki.oids) {\n    oid = pki.oids[md.algorithm];\n  } else {\n    var error = new Error('Unknown message digest algorithm.');\n    error.algorithm = md.algorithm;\n    throw error;\n  }\n  var oidBytes = asn1.oidToDer(oid).getBytes();\n\n  // create the digest info\n  var digestInfo = asn1.create(\n    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n  var digestAlgorithm = asn1.create(\n    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n  digestAlgorithm.value.push(asn1.create(\n    asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes));\n  digestAlgorithm.value.push(asn1.create(\n    asn1.Class.UNIVERSAL, asn1.Type.NULL, false, ''));\n  var digest = asn1.create(\n    asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING,\n    false, md.digest().getBytes());\n  digestInfo.value.push(digestAlgorithm);\n  digestInfo.value.push(digest);\n\n  // encode digest info\n  return asn1.toDer(digestInfo).getBytes();\n};\n\n/**\n * Performs x^c mod n (RSA encryption or decryption operation).\n *\n * @param x the number to raise and mod.\n * @param key the key to use.\n * @param pub true if the key is public, false if private.\n *\n * @return the result of x^c mod n.\n */\nvar _modPow = function(x, key, pub) {\n  if(pub) {\n    return x.modPow(key.e, key.n);\n  }\n\n  if(!key.p || !key.q) {\n    // allow calculation without CRT params (slow)\n    return x.modPow(key.d, key.n);\n  }\n\n  // pre-compute dP, dQ, and qInv if necessary\n  if(!key.dP) {\n    key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));\n  }\n  if(!key.dQ) {\n    key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));\n  }\n  if(!key.qInv) {\n    key.qInv = key.q.modInverse(key.p);\n  }\n\n  /* Chinese remainder theorem (CRT) states:\n\n    Suppose n1, n2, ..., nk are positive integers which are pairwise\n    coprime (n1 and n2 have no common factors other than 1). For any\n    integers x1, x2, ..., xk there exists an integer x solving the\n    system of simultaneous congruences (where ~= means modularly\n    congruent so a ~= b mod n means a mod n = b mod n):\n\n    x ~= x1 mod n1\n    x ~= x2 mod n2\n    ...\n    x ~= xk mod nk\n\n    This system of congruences has a single simultaneous solution x\n    between 0 and n - 1. Furthermore, each xk solution and x itself\n    is congruent modulo the product n = n1*n2*...*nk.\n    So x1 mod n = x2 mod n = xk mod n = x mod n.\n\n    The single simultaneous solution x can be solved with the following\n    equation:\n\n    x = sum(xi*ri*si) mod n where ri = n/ni and si = ri^-1 mod ni.\n\n    Where x is less than n, xi = x mod ni.\n\n    For RSA we are only concerned with k = 2. The modulus n = pq, where\n    p and q are coprime. The RSA decryption algorithm is:\n\n    y = x^d mod n\n\n    Given the above:\n\n    x1 = x^d mod p\n    r1 = n/p = q\n    s1 = q^-1 mod p\n    x2 = x^d mod q\n    r2 = n/q = p\n    s2 = p^-1 mod q\n\n    So y = (x1r1s1 + x2r2s2) mod n\n         = ((x^d mod p)q(q^-1 mod p) + (x^d mod q)p(p^-1 mod q)) mod n\n\n    According to Fermat's Little Theorem, if the modulus P is prime,\n    for any integer A not evenly divisible by P, A^(P-1) ~= 1 mod P.\n    Since A is not divisible by P it follows that if:\n    N ~= M mod (P - 1), then A^N mod P = A^M mod P. Therefore:\n\n    A^N mod P = A^(M mod (P - 1)) mod P. (The latter takes less effort\n    to calculate). In order to calculate x^d mod p more quickly the\n    exponent d mod (p - 1) is stored in the RSA private key (the same\n    is done for x^d mod q). These values are referred to as dP and dQ\n    respectively. Therefore we now have:\n\n    y = ((x^dP mod p)q(q^-1 mod p) + (x^dQ mod q)p(p^-1 mod q)) mod n\n\n    Since we'll be reducing x^dP by modulo p (same for q) we can also\n    reduce x by p (and q respectively) before hand. Therefore, let\n\n    xp = ((x mod p)^dP mod p), and\n    xq = ((x mod q)^dQ mod q), yielding:\n\n    y = (xp*q*(q^-1 mod p) + xq*p*(p^-1 mod q)) mod n\n\n    This can be further reduced to a simple algorithm that only\n    requires 1 inverse (the q inverse is used) to be used and stored.\n    The algorithm is called Garner's algorithm. If qInv is the\n    inverse of q, we simply calculate:\n\n    y = (qInv*(xp - xq) mod p) * q + xq\n\n    However, there are two further complications. First, we need to\n    ensure that xp > xq to prevent signed BigIntegers from being used\n    so we add p until this is true (since we will be mod'ing with\n    p anyway). Then, there is a known timing attack on algorithms\n    using the CRT. To mitigate this risk, \"cryptographic blinding\"\n    should be used. This requires simply generating a random number r\n    between 0 and n-1 and its inverse and multiplying x by r^e before\n    calculating y and then multiplying y by r^-1 afterwards. Note that\n    r must be coprime with n (gcd(r, n) === 1) in order to have an\n    inverse.\n  */\n\n  // cryptographic blinding\n  var r;\n  do {\n    r = new BigInteger(\n      forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)),\n      16);\n  } while(r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));\n  x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);\n\n  // calculate xp and xq\n  var xp = x.mod(key.p).modPow(key.dP, key.p);\n  var xq = x.mod(key.q).modPow(key.dQ, key.q);\n\n  // xp must be larger than xq to avoid signed bit usage\n  while(xp.compareTo(xq) < 0) {\n    xp = xp.add(key.p);\n  }\n\n  // do last step\n  var y = xp.subtract(xq)\n    .multiply(key.qInv).mod(key.p)\n    .multiply(key.q).add(xq);\n\n  // remove effect of random for cryptographic blinding\n  y = y.multiply(r.modInverse(key.n)).mod(key.n);\n\n  return y;\n};\n\n/**\n * NOTE: THIS METHOD IS DEPRECATED, use 'sign' on a private key object or\n * 'encrypt' on a public key object instead.\n *\n * Performs RSA encryption.\n *\n * The parameter bt controls whether to put padding bytes before the\n * message passed in. Set bt to either true or false to disable padding\n * completely (in order to handle e.g. EMSA-PSS encoding seperately before),\n * signaling whether the encryption operation is a public key operation\n * (i.e. encrypting data) or not, i.e. private key operation (data signing).\n *\n * For PKCS#1 v1.5 padding pass in the block type to use, i.e. either 0x01\n * (for signing) or 0x02 (for encryption). The key operation mode (private\n * or public) is derived from this flag in that case).\n *\n * @param m the message to encrypt as a byte string.\n * @param key the RSA key to use.\n * @param bt for PKCS#1 v1.5 padding, the block type to use\n *   (0x01 for private key, 0x02 for public),\n *   to disable padding: true = public key, false = private key.\n *\n * @return the encrypted bytes as a string.\n */\npki.rsa.encrypt = function(m, key, bt) {\n  var pub = bt;\n  var eb;\n\n  // get the length of the modulus in bytes\n  var k = Math.ceil(key.n.bitLength() / 8);\n\n  if(bt !== false && bt !== true) {\n    // legacy, default to PKCS#1 v1.5 padding\n    pub = (bt === 0x02);\n    eb = _encodePkcs1_v1_5(m, key, bt);\n  } else {\n    eb = forge.util.createBuffer();\n    eb.putBytes(m);\n  }\n\n  // load encryption block as big integer 'x'\n  // FIXME: hex conversion inefficient, get BigInteger w/byte strings\n  var x = new BigInteger(eb.toHex(), 16);\n\n  // do RSA encryption\n  var y = _modPow(x, key, pub);\n\n  // convert y into the encrypted data byte string, if y is shorter in\n  // bytes than k, then prepend zero bytes to fill up ed\n  // FIXME: hex conversion inefficient, get BigInteger w/byte strings\n  var yhex = y.toString(16);\n  var ed = forge.util.createBuffer();\n  var zeros = k - Math.ceil(yhex.length / 2);\n  while(zeros > 0) {\n    ed.putByte(0x00);\n    --zeros;\n  }\n  ed.putBytes(forge.util.hexToBytes(yhex));\n  return ed.getBytes();\n};\n\n/**\n * NOTE: THIS METHOD IS DEPRECATED, use 'decrypt' on a private key object or\n * 'verify' on a public key object instead.\n *\n * Performs RSA decryption.\n *\n * The parameter ml controls whether to apply PKCS#1 v1.5 padding\n * or not.  Set ml = false to disable padding removal completely\n * (in order to handle e.g. EMSA-PSS later on) and simply pass back\n * the RSA encryption block.\n *\n * @param ed the encrypted data to decrypt in as a byte string.\n * @param key the RSA key to use.\n * @param pub true for a public key operation, false for private.\n * @param ml the message length, if known, false to disable padding.\n *\n * @return the decrypted message as a byte string.\n */\npki.rsa.decrypt = function(ed, key, pub, ml) {\n  // get the length of the modulus in bytes\n  var k = Math.ceil(key.n.bitLength() / 8);\n\n  // error if the length of the encrypted data ED is not k\n  if(ed.length !== k) {\n    var error = new Error('Encrypted message length is invalid.');\n    error.length = ed.length;\n    error.expected = k;\n    throw error;\n  }\n\n  // convert encrypted data into a big integer\n  // FIXME: hex conversion inefficient, get BigInteger w/byte strings\n  var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);\n\n  // y must be less than the modulus or it wasn't the result of\n  // a previous mod operation (encryption) using that modulus\n  if(y.compareTo(key.n) >= 0) {\n    throw new Error('Encrypted message is invalid.');\n  }\n\n  // do RSA decryption\n  var x = _modPow(y, key, pub);\n\n  // create the encryption block, if x is shorter in bytes than k, then\n  // prepend zero bytes to fill up eb\n  // FIXME: hex conversion inefficient, get BigInteger w/byte strings\n  var xhex = x.toString(16);\n  var eb = forge.util.createBuffer();\n  var zeros = k - Math.ceil(xhex.length / 2);\n  while(zeros > 0) {\n    eb.putByte(0x00);\n    --zeros;\n  }\n  eb.putBytes(forge.util.hexToBytes(xhex));\n\n  if(ml !== false) {\n    // legacy, default to PKCS#1 v1.5 padding\n    return _decodePkcs1_v1_5(eb.getBytes(), key, pub);\n  }\n\n  // return message\n  return eb.getBytes();\n};\n\n/**\n * Creates an RSA key-pair generation state object. It is used to allow\n * key-generation to be performed in steps. It also allows for a UI to\n * display progress updates.\n *\n * @param bits the size for the private key in bits, defaults to 2048.\n * @param e the public exponent to use, defaults to 65537 (0x10001).\n * @param [options] the options to use.\n *          prng a custom crypto-secure pseudo-random number generator to use,\n *            that must define \"getBytesSync\".\n *          algorithm the algorithm to use (default: 'PRIMEINC').\n *\n * @return the state object to use to generate the key-pair.\n */\npki.rsa.createKeyPairGenerationState = function(bits, e, options) {\n  // TODO: migrate step-based prime generation code to forge.prime\n\n  // set default bits\n  if(typeof(bits) === 'string') {\n    bits = parseInt(bits, 10);\n  }\n  bits = bits || 2048;\n\n  // create prng with api that matches BigInteger secure random\n  options = options || {};\n  var prng = options.prng || forge.random;\n  var rng = {\n    // x is an array to fill with bytes\n    nextBytes: function(x) {\n      var b = prng.getBytesSync(x.length);\n      for(var i = 0; i < x.length; ++i) {\n        x[i] = b.charCodeAt(i);\n      }\n    }\n  };\n\n  var algorithm = options.algorithm || 'PRIMEINC';\n\n  // create PRIMEINC algorithm state\n  var rval;\n  if(algorithm === 'PRIMEINC') {\n    rval = {\n      algorithm: algorithm,\n      state: 0,\n      bits: bits,\n      rng: rng,\n      eInt: e || 65537,\n      e: new BigInteger(null),\n      p: null,\n      q: null,\n      qBits: bits >> 1,\n      pBits: bits - (bits >> 1),\n      pqState: 0,\n      num: null,\n      keys: null\n    };\n    rval.e.fromInt(rval.eInt);\n  } else {\n    throw new Error('Invalid key generation algorithm: ' + algorithm);\n  }\n\n  return rval;\n};\n\n/**\n * Attempts to runs the key-generation algorithm for at most n seconds\n * (approximately) using the given state. When key-generation has completed,\n * the keys will be stored in state.keys.\n *\n * To use this function to update a UI while generating a key or to prevent\n * causing browser lockups/warnings, set \"n\" to a value other than 0. A\n * simple pattern for generating a key and showing a progress indicator is:\n *\n * var state = pki.rsa.createKeyPairGenerationState(2048);\n * var step = function() {\n *   // step key-generation, run algorithm for 100 ms, repeat\n *   if(!forge.pki.rsa.stepKeyPairGenerationState(state, 100)) {\n *     setTimeout(step, 1);\n *   } else {\n *     // key-generation complete\n *     // TODO: turn off progress indicator here\n *     // TODO: use the generated key-pair in \"state.keys\"\n *   }\n * };\n * // TODO: turn on progress indicator here\n * setTimeout(step, 0);\n *\n * @param state the state to use.\n * @param n the maximum number of milliseconds to run the algorithm for, 0\n *          to run the algorithm to completion.\n *\n * @return true if the key-generation completed, false if not.\n */\npki.rsa.stepKeyPairGenerationState = function(state, n) {\n  // set default algorithm if not set\n  if(!('algorithm' in state)) {\n    state.algorithm = 'PRIMEINC';\n  }\n\n  // TODO: migrate step-based prime generation code to forge.prime\n  // TODO: abstract as PRIMEINC algorithm\n\n  // do key generation (based on Tom Wu's rsa.js, see jsbn.js license)\n  // with some minor optimizations and designed to run in steps\n\n  // local state vars\n  var THIRTY = new BigInteger(null);\n  THIRTY.fromInt(30);\n  var deltaIdx = 0;\n  var op_or = function(x, y) {return x | y;};\n\n  // keep stepping until time limit is reached or done\n  var t1 = +new Date();\n  var t2;\n  var total = 0;\n  while(state.keys === null && (n <= 0 || total < n)) {\n    // generate p or q\n    if(state.state === 0) {\n      /* Note: All primes are of the form:\n\n        30k+i, for i < 30 and gcd(30, i)=1, where there are 8 values for i\n\n        When we generate a random number, we always align it at 30k + 1. Each\n        time the number is determined not to be prime we add to get to the\n        next 'i', eg: if the number was at 30k + 1 we add 6. */\n      var bits = (state.p === null) ? state.pBits : state.qBits;\n      var bits1 = bits - 1;\n\n      // get a random number\n      if(state.pqState === 0) {\n        state.num = new BigInteger(bits, state.rng);\n        // force MSB set\n        if(!state.num.testBit(bits1)) {\n          state.num.bitwiseTo(\n            BigInteger.ONE.shiftLeft(bits1), op_or, state.num);\n        }\n        // align number on 30k+1 boundary\n        state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);\n        deltaIdx = 0;\n\n        ++state.pqState;\n      } else if(state.pqState === 1) {\n        // try to make the number a prime\n        if(state.num.bitLength() > bits) {\n          // overflow, try again\n          state.pqState = 0;\n          // do primality test\n        } else if(state.num.isProbablePrime(\n          _getMillerRabinTests(state.num.bitLength()))) {\n          ++state.pqState;\n        } else {\n          // get next potential prime\n          state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);\n        }\n      } else if(state.pqState === 2) {\n        // ensure number is coprime with e\n        state.pqState =\n          (state.num.subtract(BigInteger.ONE).gcd(state.e)\n            .compareTo(BigInteger.ONE) === 0) ? 3 : 0;\n      } else if(state.pqState === 3) {\n        // store p or q\n        state.pqState = 0;\n        if(state.p === null) {\n          state.p = state.num;\n        } else {\n          state.q = state.num;\n        }\n\n        // advance state if both p and q are ready\n        if(state.p !== null && state.q !== null) {\n          ++state.state;\n        }\n        state.num = null;\n      }\n    } else if(state.state === 1) {\n      // ensure p is larger than q (swap them if not)\n      if(state.p.compareTo(state.q) < 0) {\n        state.num = state.p;\n        state.p = state.q;\n        state.q = state.num;\n      }\n      ++state.state;\n    } else if(state.state === 2) {\n      // compute phi: (p - 1)(q - 1) (Euler's totient function)\n      state.p1 = state.p.subtract(BigInteger.ONE);\n      state.q1 = state.q.subtract(BigInteger.ONE);\n      state.phi = state.p1.multiply(state.q1);\n      ++state.state;\n    } else if(state.state === 3) {\n      // ensure e and phi are coprime\n      if(state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {\n        // phi and e are coprime, advance\n        ++state.state;\n      } else {\n        // phi and e aren't coprime, so generate a new p and q\n        state.p = null;\n        state.q = null;\n        state.state = 0;\n      }\n    } else if(state.state === 4) {\n      // create n, ensure n is has the right number of bits\n      state.n = state.p.multiply(state.q);\n\n      // ensure n is right number of bits\n      if(state.n.bitLength() === state.bits) {\n        // success, advance\n        ++state.state;\n      } else {\n        // failed, get new q\n        state.q = null;\n        state.state = 0;\n      }\n    } else if(state.state === 5) {\n      // set keys\n      var d = state.e.modInverse(state.phi);\n      state.keys = {\n        privateKey: pki.rsa.setPrivateKey(\n          state.n, state.e, d, state.p, state.q,\n          d.mod(state.p1), d.mod(state.q1),\n          state.q.modInverse(state.p)),\n        publicKey: pki.rsa.setPublicKey(state.n, state.e)\n      };\n    }\n\n    // update timing\n    t2 = +new Date();\n    total += t2 - t1;\n    t1 = t2;\n  }\n\n  return state.keys !== null;\n};\n\n/**\n * Generates an RSA public-private key pair in a single call.\n *\n * To generate a key-pair in steps (to allow for progress updates and to\n * prevent blocking or warnings in slow browsers) then use the key-pair\n * generation state functions.\n *\n * To generate a key-pair asynchronously (either through web-workers, if\n * available, or by breaking up the work on the main thread), pass a\n * callback function.\n *\n * @param [bits] the size for the private key in bits, defaults to 2048.\n * @param [e] the public exponent to use, defaults to 65537.\n * @param [options] options for key-pair generation, if given then 'bits'\n *            and 'e' must *not* be given:\n *          bits the size for the private key in bits, (default: 2048).\n *          e the public exponent to use, (default: 65537 (0x10001)).\n *          workerScript the worker script URL.\n *          workers the number of web workers (if supported) to use,\n *            (default: 2).\n *          workLoad the size of the work load, ie: number of possible prime\n *            numbers for each web worker to check per work assignment,\n *            (default: 100).\n *          prng a custom crypto-secure pseudo-random number generator to use,\n *            that must define \"getBytesSync\". Disables use of native APIs.\n *          algorithm the algorithm to use (default: 'PRIMEINC').\n * @param [callback(err, keypair)] called once the operation completes.\n *\n * @return an object with privateKey and publicKey properties.\n */\npki.rsa.generateKeyPair = function(bits, e, options, callback) {\n  // (bits), (options), (callback)\n  if(arguments.length === 1) {\n    if(typeof bits === 'object') {\n      options = bits;\n      bits = undefined;\n    } else if(typeof bits === 'function') {\n      callback = bits;\n      bits = undefined;\n    }\n  } else if(arguments.length === 2) {\n    // (bits, e), (bits, options), (bits, callback), (options, callback)\n    if(typeof bits === 'number') {\n      if(typeof e === 'function') {\n        callback = e;\n        e = undefined;\n      } else if(typeof e !== 'number') {\n        options = e;\n        e = undefined;\n      }\n    } else {\n      options = bits;\n      callback = e;\n      bits = undefined;\n      e = undefined;\n    }\n  } else if(arguments.length === 3) {\n    // (bits, e, options), (bits, e, callback), (bits, options, callback)\n    if(typeof e === 'number') {\n      if(typeof options === 'function') {\n        callback = options;\n        options = undefined;\n      }\n    } else {\n      callback = options;\n      options = e;\n      e = undefined;\n    }\n  }\n  options = options || {};\n  if(bits === undefined) {\n    bits = options.bits || 2048;\n  }\n  if(e === undefined) {\n    e = options.e || 0x10001;\n  }\n\n  // use native code if permitted, available, and parameters are acceptable\n  if(!forge.options.usePureJavaScript && !options.prng &&\n    bits >= 256 && bits <= 16384 && (e === 0x10001 || e === 3)) {\n    if(callback) {\n      // try native async\n      if(_detectNodeCrypto('generateKeyPair')) {\n        return _crypto.generateKeyPair('rsa', {\n          modulusLength: bits,\n          publicExponent: e,\n          publicKeyEncoding: {\n            type: 'spki',\n            format: 'pem'\n          },\n          privateKeyEncoding: {\n            type: 'pkcs8',\n            format: 'pem'\n          }\n        }, function(err, pub, priv) {\n          if(err) {\n            return callback(err);\n          }\n          callback(null, {\n            privateKey: pki.privateKeyFromPem(priv),\n            publicKey: pki.publicKeyFromPem(pub)\n          });\n        });\n      }\n      if(_detectSubtleCrypto('generateKey') &&\n        _detectSubtleCrypto('exportKey')) {\n        // use standard native generateKey\n        return util.globalScope.crypto.subtle.generateKey({\n          name: 'RSASSA-PKCS1-v1_5',\n          modulusLength: bits,\n          publicExponent: _intToUint8Array(e),\n          hash: {name: 'SHA-256'}\n        }, true /* key can be exported*/, ['sign', 'verify'])\n        .then(function(pair) {\n          return util.globalScope.crypto.subtle.exportKey(\n            'pkcs8', pair.privateKey);\n        // avoiding catch(function(err) {...}) to support IE <= 8\n        }).then(undefined, function(err) {\n          callback(err);\n        }).then(function(pkcs8) {\n          if(pkcs8) {\n            var privateKey = pki.privateKeyFromAsn1(\n              asn1.fromDer(forge.util.createBuffer(pkcs8)));\n            callback(null, {\n              privateKey: privateKey,\n              publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)\n            });\n          }\n        });\n      }\n      if(_detectSubtleMsCrypto('generateKey') &&\n        _detectSubtleMsCrypto('exportKey')) {\n        var genOp = util.globalScope.msCrypto.subtle.generateKey({\n          name: 'RSASSA-PKCS1-v1_5',\n          modulusLength: bits,\n          publicExponent: _intToUint8Array(e),\n          hash: {name: 'SHA-256'}\n        }, true /* key can be exported*/, ['sign', 'verify']);\n        genOp.oncomplete = function(e) {\n          var pair = e.target.result;\n          var exportOp = util.globalScope.msCrypto.subtle.exportKey(\n            'pkcs8', pair.privateKey);\n          exportOp.oncomplete = function(e) {\n            var pkcs8 = e.target.result;\n            var privateKey = pki.privateKeyFromAsn1(\n              asn1.fromDer(forge.util.createBuffer(pkcs8)));\n            callback(null, {\n              privateKey: privateKey,\n              publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)\n            });\n          };\n          exportOp.onerror = function(err) {\n            callback(err);\n          };\n        };\n        genOp.onerror = function(err) {\n          callback(err);\n        };\n        return;\n      }\n    } else {\n      // try native sync\n      if(_detectNodeCrypto('generateKeyPairSync')) {\n        var keypair = _crypto.generateKeyPairSync('rsa', {\n          modulusLength: bits,\n          publicExponent: e,\n          publicKeyEncoding: {\n            type: 'spki',\n            format: 'pem'\n          },\n          privateKeyEncoding: {\n            type: 'pkcs8',\n            format: 'pem'\n          }\n        });\n        return {\n          privateKey: pki.privateKeyFromPem(keypair.privateKey),\n          publicKey: pki.publicKeyFromPem(keypair.publicKey)\n        };\n      }\n    }\n  }\n\n  // use JavaScript implementation\n  var state = pki.rsa.createKeyPairGenerationState(bits, e, options);\n  if(!callback) {\n    pki.rsa.stepKeyPairGenerationState(state, 0);\n    return state.keys;\n  }\n  _generateKeyPair(state, options, callback);\n};\n\n/**\n * Sets an RSA public key from BigIntegers modulus and exponent.\n *\n * @param n the modulus.\n * @param e the exponent.\n *\n * @return the public key.\n */\npki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {\n  var key = {\n    n: n,\n    e: e\n  };\n\n  /**\n   * Encrypts the given data with this public key. Newer applications\n   * should use the 'RSA-OAEP' decryption scheme, 'RSAES-PKCS1-V1_5' is for\n   * legacy applications.\n   *\n   * @param data the byte string to encrypt.\n   * @param scheme the encryption scheme to use:\n   *          'RSAES-PKCS1-V1_5' (default),\n   *          'RSA-OAEP',\n   *          'RAW', 'NONE', or null to perform raw RSA encryption,\n   *          an object with an 'encode' property set to a function\n   *          with the signature 'function(data, key)' that returns\n   *          a binary-encoded string representing the encoded data.\n   * @param schemeOptions any scheme-specific options.\n   *\n   * @return the encrypted byte string.\n   */\n  key.encrypt = function(data, scheme, schemeOptions) {\n    if(typeof scheme === 'string') {\n      scheme = scheme.toUpperCase();\n    } else if(scheme === undefined) {\n      scheme = 'RSAES-PKCS1-V1_5';\n    }\n\n    if(scheme === 'RSAES-PKCS1-V1_5') {\n      scheme = {\n        encode: function(m, key, pub) {\n          return _encodePkcs1_v1_5(m, key, 0x02).getBytes();\n        }\n      };\n    } else if(scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {\n      scheme = {\n        encode: function(m, key) {\n          return forge.pkcs1.encode_rsa_oaep(key, m, schemeOptions);\n        }\n      };\n    } else if(['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {\n      scheme = {encode: function(e) {return e;}};\n    } else if(typeof scheme === 'string') {\n      throw new Error('Unsupported encryption scheme: \"' + scheme + '\".');\n    }\n\n    // do scheme-based encoding then rsa encryption\n    var e = scheme.encode(data, key, true);\n    return pki.rsa.encrypt(e, key, true);\n  };\n\n  /**\n   * Verifies the given signature against the given digest.\n   *\n   * PKCS#1 supports multiple (currently two) signature schemes:\n   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.\n   *\n   * By default this implementation uses the \"old scheme\", i.e.\n   * RSASSA-PKCS1-V1_5, in which case once RSA-decrypted, the\n   * signature is an OCTET STRING that holds a DigestInfo.\n   *\n   * DigestInfo ::= SEQUENCE {\n   *   digestAlgorithm DigestAlgorithmIdentifier,\n   *   digest Digest\n   * }\n   * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\n   * Digest ::= OCTET STRING\n   *\n   * To perform PSS signature verification, provide an instance\n   * of Forge PSS object as the scheme parameter.\n   *\n   * @param digest the message digest hash to compare against the signature,\n   *          as a binary-encoded string.\n   * @param signature the signature to verify, as a binary-encoded string.\n   * @param scheme signature verification scheme to use:\n   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,\n   *          a Forge PSS object for RSASSA-PSS,\n   *          'NONE' or null for none, DigestInfo will not be expected, but\n   *            PKCS#1 v1.5 padding will still be used.\n   * @param options optional verify options\n   *          _parseAllDigestBytes testing flag to control parsing of all\n   *            digest bytes. Unsupported and not for general usage.\n   *            (default: true)\n   *\n   * @return true if the signature was verified, false if not.\n   */\n  key.verify = function(digest, signature, scheme, options) {\n    if(typeof scheme === 'string') {\n      scheme = scheme.toUpperCase();\n    } else if(scheme === undefined) {\n      scheme = 'RSASSA-PKCS1-V1_5';\n    }\n    if(options === undefined) {\n      options = {\n        _parseAllDigestBytes: true\n      };\n    }\n    if(!('_parseAllDigestBytes' in options)) {\n      options._parseAllDigestBytes = true;\n    }\n\n    if(scheme === 'RSASSA-PKCS1-V1_5') {\n      scheme = {\n        verify: function(digest, d) {\n          // remove padding\n          d = _decodePkcs1_v1_5(d, key, true);\n          // d is ASN.1 BER-encoded DigestInfo\n          var obj = asn1.fromDer(d, {\n            parseAllBytes: options._parseAllDigestBytes\n          });\n\n          // validate DigestInfo\n          var capture = {};\n          var errors = [];\n          if(!asn1.validate(obj, digestInfoValidator, capture, errors)) {\n            var error = new Error(\n              'ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 ' +\n              'DigestInfo value.');\n            error.errors = errors;\n            throw error;\n          }\n          // check hash algorithm identifier\n          // see PKCS1-v1-5DigestAlgorithms in RFC 8017\n          // FIXME: add support to vaidator for strict value choices\n          var oid = asn1.derToOid(capture.algorithmIdentifier);\n          if(!(oid === forge.oids.md2 ||\n            oid === forge.oids.md5 ||\n            oid === forge.oids.sha1 ||\n            oid === forge.oids.sha224 ||\n            oid === forge.oids.sha256 ||\n            oid === forge.oids.sha384 ||\n            oid === forge.oids.sha512 ||\n            oid === forge.oids['sha512-224'] ||\n            oid === forge.oids['sha512-256'])) {\n            var error = new Error(\n              'Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.');\n            error.oid = oid;\n            throw error;\n          }\n\n          // special check for md2 and md5 that NULL parameters exist\n          if(oid === forge.oids.md2 || oid === forge.oids.md5) {\n            if(!('parameters' in capture)) {\n              throw new Error(\n                'ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 ' +\n                'DigestInfo value. ' +\n                'Missing algorithm identifer NULL parameters.');\n            }\n          }\n\n          // compare the given digest to the decrypted one\n          return digest === capture.digest;\n        }\n      };\n    } else if(scheme === 'NONE' || scheme === 'NULL' || scheme === null) {\n      scheme = {\n        verify: function(digest, d) {\n          // remove padding\n          d = _decodePkcs1_v1_5(d, key, true);\n          return digest === d;\n        }\n      };\n    }\n\n    // do rsa decryption w/o any decoding, then verify -- which does decoding\n    var d = pki.rsa.decrypt(signature, key, true, false);\n    return scheme.verify(digest, d, key.n.bitLength());\n  };\n\n  return key;\n};\n\n/**\n * Sets an RSA private key from BigIntegers modulus, exponent, primes,\n * prime exponents, and modular multiplicative inverse.\n *\n * @param n the modulus.\n * @param e the public exponent.\n * @param d the private exponent ((inverse of e) mod n).\n * @param p the first prime.\n * @param q the second prime.\n * @param dP exponent1 (d mod (p-1)).\n * @param dQ exponent2 (d mod (q-1)).\n * @param qInv ((inverse of q) mod p)\n *\n * @return the private key.\n */\npki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(\n  n, e, d, p, q, dP, dQ, qInv) {\n  var key = {\n    n: n,\n    e: e,\n    d: d,\n    p: p,\n    q: q,\n    dP: dP,\n    dQ: dQ,\n    qInv: qInv\n  };\n\n  /**\n   * Decrypts the given data with this private key. The decryption scheme\n   * must match the one used to encrypt the data.\n   *\n   * @param data the byte string to decrypt.\n   * @param scheme the decryption scheme to use:\n   *          'RSAES-PKCS1-V1_5' (default),\n   *          'RSA-OAEP',\n   *          'RAW', 'NONE', or null to perform raw RSA decryption.\n   * @param schemeOptions any scheme-specific options.\n   *\n   * @return the decrypted byte string.\n   */\n  key.decrypt = function(data, scheme, schemeOptions) {\n    if(typeof scheme === 'string') {\n      scheme = scheme.toUpperCase();\n    } else if(scheme === undefined) {\n      scheme = 'RSAES-PKCS1-V1_5';\n    }\n\n    // do rsa decryption w/o any decoding\n    var d = pki.rsa.decrypt(data, key, false, false);\n\n    if(scheme === 'RSAES-PKCS1-V1_5') {\n      scheme = {decode: _decodePkcs1_v1_5};\n    } else if(scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {\n      scheme = {\n        decode: function(d, key) {\n          return forge.pkcs1.decode_rsa_oaep(key, d, schemeOptions);\n        }\n      };\n    } else if(['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {\n      scheme = {decode: function(d) {return d;}};\n    } else {\n      throw new Error('Unsupported encryption scheme: \"' + scheme + '\".');\n    }\n\n    // decode according to scheme\n    return scheme.decode(d, key, false);\n  };\n\n  /**\n   * Signs the given digest, producing a signature.\n   *\n   * PKCS#1 supports multiple (currently two) signature schemes:\n   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.\n   *\n   * By default this implementation uses the \"old scheme\", i.e.\n   * RSASSA-PKCS1-V1_5. In order to generate a PSS signature, provide\n   * an instance of Forge PSS object as the scheme parameter.\n   *\n   * @param md the message digest object with the hash to sign.\n   * @param scheme the signature scheme to use:\n   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,\n   *          a Forge PSS object for RSASSA-PSS,\n   *          'NONE' or null for none, DigestInfo will not be used but\n   *            PKCS#1 v1.5 padding will still be used.\n   *\n   * @return the signature as a byte string.\n   */\n  key.sign = function(md, scheme) {\n    /* Note: The internal implementation of RSA operations is being\n      transitioned away from a PKCS#1 v1.5 hard-coded scheme. Some legacy\n      code like the use of an encoding block identifier 'bt' will eventually\n      be removed. */\n\n    // private key operation\n    var bt = false;\n\n    if(typeof scheme === 'string') {\n      scheme = scheme.toUpperCase();\n    }\n\n    if(scheme === undefined || scheme === 'RSASSA-PKCS1-V1_5') {\n      scheme = {encode: emsaPkcs1v15encode};\n      bt = 0x01;\n    } else if(scheme === 'NONE' || scheme === 'NULL' || scheme === null) {\n      scheme = {encode: function() {return md;}};\n      bt = 0x01;\n    }\n\n    // encode and then encrypt\n    var d = scheme.encode(md, key.n.bitLength());\n    return pki.rsa.encrypt(d, key, bt);\n  };\n\n  return key;\n};\n\n/**\n * Wraps an RSAPrivateKey ASN.1 object in an ASN.1 PrivateKeyInfo object.\n *\n * @param rsaKey the ASN.1 RSAPrivateKey.\n *\n * @return the ASN.1 PrivateKeyInfo.\n */\npki.wrapRsaPrivateKey = function(rsaKey) {\n  // PrivateKeyInfo\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // version (0)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      asn1.integerToDer(0).getBytes()),\n    // privateKeyAlgorithm\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      asn1.create(\n        asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n        asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\n    ]),\n    // PrivateKey\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n      asn1.toDer(rsaKey).getBytes())\n  ]);\n};\n\n/**\n * Converts a private key from an ASN.1 object.\n *\n * @param obj the ASN.1 representation of a PrivateKeyInfo containing an\n *          RSAPrivateKey or an RSAPrivateKey.\n *\n * @return the private key.\n */\npki.privateKeyFromAsn1 = function(obj) {\n  // get PrivateKeyInfo\n  var capture = {};\n  var errors = [];\n  if(asn1.validate(obj, privateKeyValidator, capture, errors)) {\n    obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));\n  }\n\n  // get RSAPrivateKey\n  capture = {};\n  errors = [];\n  if(!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {\n    var error = new Error('Cannot read private key. ' +\n      'ASN.1 object does not contain an RSAPrivateKey.');\n    error.errors = errors;\n    throw error;\n  }\n\n  // Note: Version is currently ignored.\n  // capture.privateKeyVersion\n  // FIXME: inefficient, get a BigInteger that uses byte strings\n  var n, e, d, p, q, dP, dQ, qInv;\n  n = forge.util.createBuffer(capture.privateKeyModulus).toHex();\n  e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();\n  d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();\n  p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();\n  q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();\n  dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();\n  dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();\n  qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();\n\n  // set private key\n  return pki.setRsaPrivateKey(\n    new BigInteger(n, 16),\n    new BigInteger(e, 16),\n    new BigInteger(d, 16),\n    new BigInteger(p, 16),\n    new BigInteger(q, 16),\n    new BigInteger(dP, 16),\n    new BigInteger(dQ, 16),\n    new BigInteger(qInv, 16));\n};\n\n/**\n * Converts a private key to an ASN.1 RSAPrivateKey.\n *\n * @param key the private key.\n *\n * @return the ASN.1 representation of an RSAPrivateKey.\n */\npki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {\n  // RSAPrivateKey\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // version (0 = only 2 primes, 1 multiple primes)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      asn1.integerToDer(0).getBytes()),\n    // modulus (n)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.n)),\n    // publicExponent (e)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.e)),\n    // privateExponent (d)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.d)),\n    // privateKeyPrime1 (p)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.p)),\n    // privateKeyPrime2 (q)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.q)),\n    // privateKeyExponent1 (dP)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.dP)),\n    // privateKeyExponent2 (dQ)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.dQ)),\n    // coefficient (qInv)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.qInv))\n  ]);\n};\n\n/**\n * Converts a public key from an ASN.1 SubjectPublicKeyInfo or RSAPublicKey.\n *\n * @param obj the asn1 representation of a SubjectPublicKeyInfo or RSAPublicKey.\n *\n * @return the public key.\n */\npki.publicKeyFromAsn1 = function(obj) {\n  // get SubjectPublicKeyInfo\n  var capture = {};\n  var errors = [];\n  if(asn1.validate(obj, publicKeyValidator, capture, errors)) {\n    // get oid\n    var oid = asn1.derToOid(capture.publicKeyOid);\n    if(oid !== pki.oids.rsaEncryption) {\n      var error = new Error('Cannot read public key. Unknown OID.');\n      error.oid = oid;\n      throw error;\n    }\n    obj = capture.rsaPublicKey;\n  }\n\n  // get RSA params\n  errors = [];\n  if(!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {\n    var error = new Error('Cannot read public key. ' +\n      'ASN.1 object does not contain an RSAPublicKey.');\n    error.errors = errors;\n    throw error;\n  }\n\n  // FIXME: inefficient, get a BigInteger that uses byte strings\n  var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();\n  var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();\n\n  // set public key\n  return pki.setRsaPublicKey(\n    new BigInteger(n, 16),\n    new BigInteger(e, 16));\n};\n\n/**\n * Converts a public key to an ASN.1 SubjectPublicKeyInfo.\n *\n * @param key the public key.\n *\n * @return the asn1 representation of a SubjectPublicKeyInfo.\n */\npki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {\n  // SubjectPublicKeyInfo\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // AlgorithmIdentifier\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // algorithm\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n        asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),\n      // parameters (null)\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\n    ]),\n    // subjectPublicKey\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [\n      pki.publicKeyToRSAPublicKey(key)\n    ])\n  ]);\n};\n\n/**\n * Converts a public key to an ASN.1 RSAPublicKey.\n *\n * @param key the public key.\n *\n * @return the asn1 representation of a RSAPublicKey.\n */\npki.publicKeyToRSAPublicKey = function(key) {\n  // RSAPublicKey\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // modulus (n)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.n)),\n    // publicExponent (e)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.e))\n  ]);\n};\n\n/**\n * Encodes a message using PKCS#1 v1.5 padding.\n *\n * @param m the message to encode.\n * @param key the RSA key to use.\n * @param bt the block type to use, i.e. either 0x01 (for signing) or 0x02\n *          (for encryption).\n *\n * @return the padded byte buffer.\n */\nfunction _encodePkcs1_v1_5(m, key, bt) {\n  var eb = forge.util.createBuffer();\n\n  // get the length of the modulus in bytes\n  var k = Math.ceil(key.n.bitLength() / 8);\n\n  /* use PKCS#1 v1.5 padding */\n  if(m.length > (k - 11)) {\n    var error = new Error('Message is too long for PKCS#1 v1.5 padding.');\n    error.length = m.length;\n    error.max = k - 11;\n    throw error;\n  }\n\n  /* A block type BT, a padding string PS, and the data D shall be\n    formatted into an octet string EB, the encryption block:\n\n    EB = 00 || BT || PS || 00 || D\n\n    The block type BT shall be a single octet indicating the structure of\n    the encryption block. For this version of the document it shall have\n    value 00, 01, or 02. For a private-key operation, the block type\n    shall be 00 or 01. For a public-key operation, it shall be 02.\n\n    The padding string PS shall consist of k-3-||D|| octets. For block\n    type 00, the octets shall have value 00; for block type 01, they\n    shall have value FF; and for block type 02, they shall be\n    pseudorandomly generated and nonzero. This makes the length of the\n    encryption block EB equal to k. */\n\n  // build the encryption block\n  eb.putByte(0x00);\n  eb.putByte(bt);\n\n  // create the padding\n  var padNum = k - 3 - m.length;\n  var padByte;\n  // private key op\n  if(bt === 0x00 || bt === 0x01) {\n    padByte = (bt === 0x00) ? 0x00 : 0xFF;\n    for(var i = 0; i < padNum; ++i) {\n      eb.putByte(padByte);\n    }\n  } else {\n    // public key op\n    // pad with random non-zero values\n    while(padNum > 0) {\n      var numZeros = 0;\n      var padBytes = forge.random.getBytes(padNum);\n      for(var i = 0; i < padNum; ++i) {\n        padByte = padBytes.charCodeAt(i);\n        if(padByte === 0) {\n          ++numZeros;\n        } else {\n          eb.putByte(padByte);\n        }\n      }\n      padNum = numZeros;\n    }\n  }\n\n  // zero followed by message\n  eb.putByte(0x00);\n  eb.putBytes(m);\n\n  return eb;\n}\n\n/**\n * Decodes a message using PKCS#1 v1.5 padding.\n *\n * @param em the message to decode.\n * @param key the RSA key to use.\n * @param pub true if the key is a public key, false if it is private.\n * @param ml the message length, if specified.\n *\n * @return the decoded bytes.\n */\nfunction _decodePkcs1_v1_5(em, key, pub, ml) {\n  // get the length of the modulus in bytes\n  var k = Math.ceil(key.n.bitLength() / 8);\n\n  /* It is an error if any of the following conditions occurs:\n\n    1. The encryption block EB cannot be parsed unambiguously.\n    2. The padding string PS consists of fewer than eight octets\n      or is inconsisent with the block type BT.\n    3. The decryption process is a public-key operation and the block\n      type BT is not 00 or 01, or the decryption process is a\n      private-key operation and the block type is not 02.\n   */\n\n  // parse the encryption block\n  var eb = forge.util.createBuffer(em);\n  var first = eb.getByte();\n  var bt = eb.getByte();\n  if(first !== 0x00 ||\n    (pub && bt !== 0x00 && bt !== 0x01) ||\n    (!pub && bt != 0x02) ||\n    (pub && bt === 0x00 && typeof(ml) === 'undefined')) {\n    throw new Error('Encryption block is invalid.');\n  }\n\n  var padNum = 0;\n  if(bt === 0x00) {\n    // check all padding bytes for 0x00\n    padNum = k - 3 - ml;\n    for(var i = 0; i < padNum; ++i) {\n      if(eb.getByte() !== 0x00) {\n        throw new Error('Encryption block is invalid.');\n      }\n    }\n  } else if(bt === 0x01) {\n    // find the first byte that isn't 0xFF, should be after all padding\n    padNum = 0;\n    while(eb.length() > 1) {\n      if(eb.getByte() !== 0xFF) {\n        --eb.read;\n        break;\n      }\n      ++padNum;\n    }\n  } else if(bt === 0x02) {\n    // look for 0x00 byte\n    padNum = 0;\n    while(eb.length() > 1) {\n      if(eb.getByte() === 0x00) {\n        --eb.read;\n        break;\n      }\n      ++padNum;\n    }\n  }\n\n  // zero must be 0x00 and padNum must be (k - 3 - message length)\n  var zero = eb.getByte();\n  if(zero !== 0x00 || padNum !== (k - 3 - eb.length())) {\n    throw new Error('Encryption block is invalid.');\n  }\n\n  return eb.getBytes();\n}\n\n/**\n * Runs the key-generation algorithm asynchronously, either in the background\n * via Web Workers, or using the main thread and setImmediate.\n *\n * @param state the key-pair generation state.\n * @param [options] options for key-pair generation:\n *          workerScript the worker script URL.\n *          workers the number of web workers (if supported) to use,\n *            (default: 2, -1 to use estimated cores minus one).\n *          workLoad the size of the work load, ie: number of possible prime\n *            numbers for each web worker to check per work assignment,\n *            (default: 100).\n * @param callback(err, keypair) called once the operation completes.\n */\nfunction _generateKeyPair(state, options, callback) {\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n\n  var opts = {\n    algorithm: {\n      name: options.algorithm || 'PRIMEINC',\n      options: {\n        workers: options.workers || 2,\n        workLoad: options.workLoad || 100,\n        workerScript: options.workerScript\n      }\n    }\n  };\n  if('prng' in options) {\n    opts.prng = options.prng;\n  }\n\n  generate();\n\n  function generate() {\n    // find p and then q (done in series to simplify)\n    getPrime(state.pBits, function(err, num) {\n      if(err) {\n        return callback(err);\n      }\n      state.p = num;\n      if(state.q !== null) {\n        return finish(err, state.q);\n      }\n      getPrime(state.qBits, finish);\n    });\n  }\n\n  function getPrime(bits, callback) {\n    forge.prime.generateProbablePrime(bits, opts, callback);\n  }\n\n  function finish(err, num) {\n    if(err) {\n      return callback(err);\n    }\n\n    // set q\n    state.q = num;\n\n    // ensure p is larger than q (swap them if not)\n    if(state.p.compareTo(state.q) < 0) {\n      var tmp = state.p;\n      state.p = state.q;\n      state.q = tmp;\n    }\n\n    // ensure p is coprime with e\n    if(state.p.subtract(BigInteger.ONE).gcd(state.e)\n      .compareTo(BigInteger.ONE) !== 0) {\n      state.p = null;\n      generate();\n      return;\n    }\n\n    // ensure q is coprime with e\n    if(state.q.subtract(BigInteger.ONE).gcd(state.e)\n      .compareTo(BigInteger.ONE) !== 0) {\n      state.q = null;\n      getPrime(state.qBits, finish);\n      return;\n    }\n\n    // compute phi: (p - 1)(q - 1) (Euler's totient function)\n    state.p1 = state.p.subtract(BigInteger.ONE);\n    state.q1 = state.q.subtract(BigInteger.ONE);\n    state.phi = state.p1.multiply(state.q1);\n\n    // ensure e and phi are coprime\n    if(state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {\n      // phi and e aren't coprime, so generate a new p and q\n      state.p = state.q = null;\n      generate();\n      return;\n    }\n\n    // create n, ensure n is has the right number of bits\n    state.n = state.p.multiply(state.q);\n    if(state.n.bitLength() !== state.bits) {\n      // failed, get new q\n      state.q = null;\n      getPrime(state.qBits, finish);\n      return;\n    }\n\n    // set keys\n    var d = state.e.modInverse(state.phi);\n    state.keys = {\n      privateKey: pki.rsa.setPrivateKey(\n        state.n, state.e, d, state.p, state.q,\n        d.mod(state.p1), d.mod(state.q1),\n        state.q.modInverse(state.p)),\n      publicKey: pki.rsa.setPublicKey(state.n, state.e)\n    };\n\n    callback(null, state.keys);\n  }\n}\n\n/**\n * Converts a positive BigInteger into 2's-complement big-endian bytes.\n *\n * @param b the big integer to convert.\n *\n * @return the bytes.\n */\nfunction _bnToBytes(b) {\n  // prepend 0x00 if first byte >= 0x80\n  var hex = b.toString(16);\n  if(hex[0] >= '8') {\n    hex = '00' + hex;\n  }\n  var bytes = forge.util.hexToBytes(hex);\n\n  // ensure integer is minimally-encoded\n  if(bytes.length > 1 &&\n    // leading 0x00 for positive integer\n    ((bytes.charCodeAt(0) === 0 &&\n    (bytes.charCodeAt(1) & 0x80) === 0) ||\n    // leading 0xFF for negative integer\n    (bytes.charCodeAt(0) === 0xFF &&\n    (bytes.charCodeAt(1) & 0x80) === 0x80))) {\n    return bytes.substr(1);\n  }\n  return bytes;\n}\n\n/**\n * Returns the required number of Miller-Rabin tests to generate a\n * prime with an error probability of (1/2)^80.\n *\n * See Handbook of Applied Cryptography Chapter 4, Table 4.4.\n *\n * @param bits the bit size.\n *\n * @return the required number of iterations.\n */\nfunction _getMillerRabinTests(bits) {\n  if(bits <= 100) return 27;\n  if(bits <= 150) return 18;\n  if(bits <= 200) return 15;\n  if(bits <= 250) return 12;\n  if(bits <= 300) return 9;\n  if(bits <= 350) return 8;\n  if(bits <= 400) return 7;\n  if(bits <= 500) return 6;\n  if(bits <= 600) return 5;\n  if(bits <= 800) return 4;\n  if(bits <= 1250) return 3;\n  return 2;\n}\n\n/**\n * Performs feature detection on the Node crypto interface.\n *\n * @param fn the feature (function) to detect.\n *\n * @return true if detected, false if not.\n */\nfunction _detectNodeCrypto(fn) {\n  return forge.util.isNodejs && typeof _crypto[fn] === 'function';\n}\n\n/**\n * Performs feature detection on the SubtleCrypto interface.\n *\n * @param fn the feature (function) to detect.\n *\n * @return true if detected, false if not.\n */\nfunction _detectSubtleCrypto(fn) {\n  return (typeof util.globalScope !== 'undefined' &&\n    typeof util.globalScope.crypto === 'object' &&\n    typeof util.globalScope.crypto.subtle === 'object' &&\n    typeof util.globalScope.crypto.subtle[fn] === 'function');\n}\n\n/**\n * Performs feature detection on the deprecated Microsoft Internet Explorer\n * outdated SubtleCrypto interface. This function should only be used after\n * checking for the modern, standard SubtleCrypto interface.\n *\n * @param fn the feature (function) to detect.\n *\n * @return true if detected, false if not.\n */\nfunction _detectSubtleMsCrypto(fn) {\n  return (typeof util.globalScope !== 'undefined' &&\n    typeof util.globalScope.msCrypto === 'object' &&\n    typeof util.globalScope.msCrypto.subtle === 'object' &&\n    typeof util.globalScope.msCrypto.subtle[fn] === 'function');\n}\n\nfunction _intToUint8Array(x) {\n  var bytes = forge.util.hexToBytes(x.toString(16));\n  var buffer = new Uint8Array(bytes.length);\n  for(var i = 0; i < bytes.length; ++i) {\n    buffer[i] = bytes.charCodeAt(i);\n  }\n  return buffer;\n}\n\nfunction _privateKeyFromJwk(jwk) {\n  if(jwk.kty !== 'RSA') {\n    throw new Error(\n      'Unsupported key algorithm \"' + jwk.kty + '\"; algorithm must be \"RSA\".');\n  }\n  return pki.setRsaPrivateKey(\n    _base64ToBigInt(jwk.n),\n    _base64ToBigInt(jwk.e),\n    _base64ToBigInt(jwk.d),\n    _base64ToBigInt(jwk.p),\n    _base64ToBigInt(jwk.q),\n    _base64ToBigInt(jwk.dp),\n    _base64ToBigInt(jwk.dq),\n    _base64ToBigInt(jwk.qi));\n}\n\nfunction _publicKeyFromJwk(jwk) {\n  if(jwk.kty !== 'RSA') {\n    throw new Error('Key algorithm must be \"RSA\".');\n  }\n  return pki.setRsaPublicKey(\n    _base64ToBigInt(jwk.n),\n    _base64ToBigInt(jwk.e));\n}\n\nfunction _base64ToBigInt(b64) {\n  return new BigInteger(forge.util.bytesToHex(forge.util.decode64(b64)), 16);\n}\n"],
  "mappings": "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",
  "names": ["md", "_crypto", "i", "listener", "jQuery", "key", "i", "e", "key", "digest", "d", "callback"]
}
