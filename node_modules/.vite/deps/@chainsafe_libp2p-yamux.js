import {
  abortableSource
} from "./chunk-5KM2WXVC.js";
import {
  anySignal
} from "./chunk-LVRF3CZC.js";
import {
  logger
} from "./chunk-WDWZMECJ.js";
import "./chunk-BOUIN2HE.js";
import "./chunk-M46RNIVP.js";
import "./chunk-DEKXFOR2.js";
import "./chunk-WIZTS4EN.js";
import "./chunk-IIVECPVT.js";
import {
  pipe
} from "./chunk-LR5OG27U.js";
import "./chunk-J4GXRM4P.js";
import {
  pushable
} from "./chunk-GCFO4FX4.js";
import "./chunk-YUNCDTIA.js";
import {
  Uint8ArrayList
} from "./chunk-ADNOUI46.js";
import {
  CodeError
} from "./chunk-3AY7ONUU.js";
import "./chunk-SD7KC3ZF.js";
import "./chunk-QA7JUXLP.js";
import "./chunk-GSGWBNT6.js";
import "./chunk-7CPFPK54.js";
import {
  __publicField
} from "./chunk-CWJX2WJ3.js";

// ../../node_modules/@chainsafe/libp2p-yamux/dist/src/constants.js
var ERR_INVALID_FRAME = "ERR_INVALID_FRAME";
var ERR_UNREQUESTED_PING = "ERR_UNREQUESTED_PING";
var ERR_NOT_MATCHING_PING = "ERR_NOT_MATCHING_PING";
var ERR_STREAM_ALREADY_EXISTS = "ERR_STREAM_ALREADY_EXISTS";
var ERR_DECODE_INVALID_VERSION = "ERR_DECODE_INVALID_VERSION";
var ERR_BOTH_CLIENTS = "ERR_BOTH_CLIENTS";
var ERR_RECV_WINDOW_EXCEEDED = "ERR_RECV_WINDOW_EXCEEDED";
var PROTOCOL_ERRORS = /* @__PURE__ */ new Set([
  ERR_INVALID_FRAME,
  ERR_UNREQUESTED_PING,
  ERR_NOT_MATCHING_PING,
  ERR_STREAM_ALREADY_EXISTS,
  ERR_DECODE_INVALID_VERSION,
  ERR_BOTH_CLIENTS,
  ERR_RECV_WINDOW_EXCEEDED
]);
var ERR_INVALID_CONFIG = "ERR_INVALID_CONFIG";
var ERR_MUXER_LOCAL_CLOSED = "ERR_MUXER_LOCAL_CLOSED";
var ERR_MUXER_REMOTE_CLOSED = "ERR_MUXER_REMOTE_CLOSED";
var ERR_STREAM_RESET = "ERR_STREAM_RESET";
var ERR_STREAM_ABORT = "ERR_STREAM_ABORT";
var ERR_MAX_OUTBOUND_STREAMS_EXCEEDED = "ERROR_MAX_OUTBOUND_STREAMS_EXCEEDED";
var ERR_DECODE_IN_PROGRESS = "ERR_DECODE_IN_PROGRESS";
var INITIAL_STREAM_WINDOW = 256 * 1024;
var MAX_STREAM_WINDOW = 16 * 1024 * 1024;

// ../../node_modules/@chainsafe/libp2p-yamux/dist/src/config.js
var defaultConfig = {
  log: logger("libp2p:yamux"),
  enableKeepAlive: true,
  keepAliveInterval: 3e4,
  maxInboundStreams: 1e3,
  maxOutboundStreams: 1e3,
  initialStreamWindowSize: INITIAL_STREAM_WINDOW,
  maxStreamWindowSize: MAX_STREAM_WINDOW,
  maxMessageSize: 64 * 1024
};
function verifyConfig(config) {
  if (config.keepAliveInterval <= 0) {
    throw new CodeError("keep-alive interval must be positive", ERR_INVALID_CONFIG);
  }
  if (config.maxInboundStreams < 0) {
    throw new CodeError("max inbound streams must be larger or equal 0", ERR_INVALID_CONFIG);
  }
  if (config.maxOutboundStreams < 0) {
    throw new CodeError("max outbound streams must be larger or equal 0", ERR_INVALID_CONFIG);
  }
  if (config.initialStreamWindowSize < INITIAL_STREAM_WINDOW) {
    throw new CodeError("InitialStreamWindowSize must be larger or equal 256 kB", ERR_INVALID_CONFIG);
  }
  if (config.maxStreamWindowSize < config.initialStreamWindowSize) {
    throw new CodeError("MaxStreamWindowSize must be larger than the InitialStreamWindowSize", ERR_INVALID_CONFIG);
  }
  if (config.maxStreamWindowSize > 2 ** 32 - 1) {
    throw new CodeError("MaxStreamWindowSize must be less than equal MAX_UINT32", ERR_INVALID_CONFIG);
  }
  if (config.maxMessageSize < 1024) {
    throw new CodeError("MaxMessageSize must be greater than a kilobyte", ERR_INVALID_CONFIG);
  }
}

// ../../node_modules/@chainsafe/libp2p-yamux/dist/src/frame.js
var FrameType;
(function(FrameType2) {
  FrameType2[FrameType2["Data"] = 0] = "Data";
  FrameType2[FrameType2["WindowUpdate"] = 1] = "WindowUpdate";
  FrameType2[FrameType2["Ping"] = 2] = "Ping";
  FrameType2[FrameType2["GoAway"] = 3] = "GoAway";
})(FrameType || (FrameType = {}));
var Flag;
(function(Flag2) {
  Flag2[Flag2["SYN"] = 1] = "SYN";
  Flag2[Flag2["ACK"] = 2] = "ACK";
  Flag2[Flag2["FIN"] = 4] = "FIN";
  Flag2[Flag2["RST"] = 8] = "RST";
})(Flag || (Flag = {}));
var flagCodes = Object.values(Flag).filter((x) => typeof x !== "string");
var YAMUX_VERSION = 0;
var GoAwayCode;
(function(GoAwayCode2) {
  GoAwayCode2[GoAwayCode2["NormalTermination"] = 0] = "NormalTermination";
  GoAwayCode2[GoAwayCode2["ProtocolError"] = 1] = "ProtocolError";
  GoAwayCode2[GoAwayCode2["InternalError"] = 2] = "InternalError";
})(GoAwayCode || (GoAwayCode = {}));
var HEADER_LENGTH = 12;
function stringifyHeader(header) {
  const flags = flagCodes.filter((f) => (header.flag & f) === f).map((f) => Flag[f]).join("|");
  return `streamID=${header.streamID} type=${FrameType[header.type]} flag=${flags} length=${header.length}`;
}

// ../../node_modules/@chainsafe/libp2p-yamux/dist/src/decode.js
var twoPow24 = 2 ** 24;
function decodeHeader(data) {
  if (data[0] !== YAMUX_VERSION) {
    throw new CodeError("Invalid frame version", ERR_DECODE_INVALID_VERSION);
  }
  return {
    type: data[1],
    flag: (data[2] << 8) + data[3],
    streamID: data[4] * twoPow24 + (data[5] << 16) + (data[6] << 8) + data[7],
    length: data[8] * twoPow24 + (data[9] << 16) + (data[10] << 8) + data[11]
  };
}
var Decoder = class {
  constructor(source) {
    __publicField(this, "source");
    __publicField(this, "buffer");
    __publicField(this, "frameInProgress");
    this.source = returnlessSource(source);
    this.buffer = new Uint8ArrayList();
    this.frameInProgress = false;
  }
  async *emitFrames() {
    for await (const chunk of this.source) {
      this.buffer.append(chunk);
      while (true) {
        const header = this.readHeader();
        if (header === void 0) {
          break;
        }
        const { type, length } = header;
        if (type === FrameType.Data) {
          this.frameInProgress = true;
          yield {
            header,
            readData: this.readBytes.bind(this, length)
          };
        } else {
          yield { header };
        }
      }
    }
  }
  readHeader() {
    if (this.frameInProgress) {
      throw new CodeError("decoding frame already in progress", ERR_DECODE_IN_PROGRESS);
    }
    if (this.buffer.length < HEADER_LENGTH) {
      return;
    }
    const header = decodeHeader(this.buffer.subarray(0, HEADER_LENGTH));
    this.buffer.consume(HEADER_LENGTH);
    return header;
  }
  async readBytes(length) {
    if (this.buffer.length < length) {
      for await (const chunk of this.source) {
        this.buffer.append(chunk);
        if (this.buffer.length >= length) {
          break;
        }
      }
    }
    const out = this.buffer.sublist(0, length);
    this.buffer.consume(length);
    this.frameInProgress = false;
    return out;
  }
};
function returnlessSource(source) {
  if (source[Symbol.iterator] !== void 0) {
    const iterator = source[Symbol.iterator]();
    iterator.return = void 0;
    return {
      [Symbol.iterator]() {
        return iterator;
      }
    };
  } else if (source[Symbol.asyncIterator] !== void 0) {
    const iterator = source[Symbol.asyncIterator]();
    iterator.return = void 0;
    return {
      [Symbol.asyncIterator]() {
        return iterator;
      }
    };
  } else {
    throw new Error("a source must be either an iterable or an async iterable");
  }
}

// ../../node_modules/@chainsafe/libp2p-yamux/dist/src/encode.js
function encodeHeader(header) {
  const frame = new Uint8Array(HEADER_LENGTH);
  frame[1] = header.type;
  frame[2] = header.flag >>> 8;
  frame[3] = header.flag;
  frame[4] = header.streamID >>> 24;
  frame[5] = header.streamID >>> 16;
  frame[6] = header.streamID >>> 8;
  frame[7] = header.streamID;
  frame[8] = header.length >>> 24;
  frame[9] = header.length >>> 16;
  frame[10] = header.length >>> 8;
  frame[11] = header.length;
  return frame;
}

// ../../node_modules/@chainsafe/libp2p-yamux/dist/src/stream.js
var StreamState;
(function(StreamState2) {
  StreamState2[StreamState2["Init"] = 0] = "Init";
  StreamState2[StreamState2["SYNSent"] = 1] = "SYNSent";
  StreamState2[StreamState2["SYNReceived"] = 2] = "SYNReceived";
  StreamState2[StreamState2["Established"] = 3] = "Established";
  StreamState2[StreamState2["Finished"] = 4] = "Finished";
})(StreamState || (StreamState = {}));
var HalfStreamState;
(function(HalfStreamState2) {
  HalfStreamState2[HalfStreamState2["Open"] = 0] = "Open";
  HalfStreamState2[HalfStreamState2["Closed"] = 1] = "Closed";
  HalfStreamState2[HalfStreamState2["Reset"] = 2] = "Reset";
})(HalfStreamState || (HalfStreamState = {}));
var YamuxStream = class {
  constructor(init) {
    __publicField(this, "id");
    __publicField(this, "name");
    __publicField(this, "stat");
    __publicField(this, "metadata");
    __publicField(this, "state");
    __publicField(this, "readState");
    __publicField(this, "writeState");
    __publicField(this, "sourceInput");
    __publicField(this, "source");
    __publicField(this, "sink");
    __publicField(this, "config");
    __publicField(this, "log");
    __publicField(this, "_id");
    __publicField(this, "sendWindowCapacity");
    __publicField(this, "sendWindowCapacityUpdate");
    __publicField(this, "recvWindow");
    __publicField(this, "recvWindowCapacity");
    __publicField(this, "epochStart");
    __publicField(this, "getRTT");
    __publicField(this, "abortController");
    __publicField(this, "sendFrame");
    __publicField(this, "onStreamEnd");
    this.config = init.config;
    this.log = init.log;
    this._id = init.id;
    this.id = String(init.id);
    this.name = init.name;
    this.stat = {
      direction: init.direction,
      timeline: {
        open: Date.now()
      }
    };
    this.metadata = {};
    this.state = init.state;
    this.readState = HalfStreamState.Open;
    this.writeState = HalfStreamState.Open;
    this.sendWindowCapacity = INITIAL_STREAM_WINDOW;
    this.recvWindow = this.config.initialStreamWindowSize;
    this.recvWindowCapacity = this.recvWindow;
    this.epochStart = Date.now();
    this.getRTT = init.getRTT;
    this.abortController = new AbortController();
    this.sendFrame = init.sendFrame;
    this.onStreamEnd = init.onStreamEnd;
    this.sourceInput = pushable({
      onEnd: (err) => {
        if (err != null) {
          this.log?.error("stream source ended id=%s", this._id, err);
        } else {
          this.log?.trace("stream source ended id=%s", this._id);
        }
        this.closeRead();
      }
    });
    this.source = this.createSource();
    this.sink = async (source) => {
      if (this.writeState !== HalfStreamState.Open) {
        throw new Error("stream closed for writing");
      }
      source = abortableSource(source, this.abortController.signal, { returnOnAbort: true });
      try {
        for await (let data of source) {
          while (data.length !== 0) {
            if (this.sendWindowCapacity === 0)
              await this.waitForSendWindowCapacity();
            const toSend = Math.min(this.sendWindowCapacity, this.config.maxMessageSize - HEADER_LENGTH, data.length);
            this.sendData(data.subarray(0, toSend));
            this.sendWindowCapacity -= toSend;
            data = data.subarray(toSend);
          }
        }
      } catch (e) {
        this.log?.error("stream sink error id=%s", this._id, e);
      } finally {
        this.log?.trace("stream sink ended id=%s", this._id);
        this.closeWrite();
      }
    };
  }
  async *createSource() {
    try {
      for await (const val of this.sourceInput) {
        this.sendWindowUpdate();
        yield val;
      }
    } catch (err) {
      const errCode = err.code;
      if (errCode !== ERR_STREAM_ABORT) {
        this.log?.error("stream source error id=%s", this._id, err);
        throw err;
      }
    }
  }
  close() {
    this.log?.trace("stream close id=%s", this._id);
    this.closeRead();
    this.closeWrite();
  }
  closeRead() {
    if (this.state === StreamState.Finished) {
      return;
    }
    if (this.readState !== HalfStreamState.Open) {
      return;
    }
    this.log?.trace("stream close read id=%s", this._id);
    this.readState = HalfStreamState.Closed;
    this.sourceInput.end();
    if (this.writeState !== HalfStreamState.Open) {
      this.finish();
    }
  }
  closeWrite() {
    if (this.state === StreamState.Finished) {
      return;
    }
    if (this.writeState !== HalfStreamState.Open) {
      return;
    }
    this.log?.trace("stream close write id=%s", this._id);
    this.writeState = HalfStreamState.Closed;
    this.sendClose();
    this.abortController.abort();
    if (this.readState !== HalfStreamState.Open) {
      this.finish();
    }
  }
  abort(err) {
    switch (this.state) {
      case StreamState.Finished:
        return;
      case StreamState.Init:
        break;
      case StreamState.SYNSent:
      case StreamState.SYNReceived:
      case StreamState.Established:
        this.sendReset();
        break;
      default:
        throw new Error("unreachable");
    }
    if (err != null) {
      this.log?.error("stream abort id=%s error=%s", this._id, err);
    } else {
      this.log?.trace("stream abort id=%s", this._id);
    }
    this.onReset(new CodeError(String(err) ?? "stream aborted", ERR_STREAM_ABORT));
  }
  reset() {
    if (this.state === StreamState.Finished) {
      return;
    }
    this.log?.trace("stream reset id=%s", this._id);
    this.onReset(new CodeError("stream reset", ERR_STREAM_RESET));
  }
  onReset(err) {
    if (this.writeState === HalfStreamState.Open) {
      this.writeState = HalfStreamState.Reset;
    }
    if (this.readState === HalfStreamState.Open) {
      this.readState = HalfStreamState.Reset;
    }
    this.state = StreamState.Finished;
    this.sourceInput.end(err);
    this.abortController.abort();
    this.finish();
  }
  async waitForSendWindowCapacity() {
    if (this.abortController.signal.aborted) {
      throw new CodeError("stream aborted", ERR_STREAM_ABORT);
    }
    if (this.sendWindowCapacity > 0) {
      return;
    }
    let reject;
    const abort = () => {
      reject(new CodeError("stream aborted", ERR_STREAM_ABORT));
    };
    this.abortController.signal.addEventListener("abort", abort);
    await new Promise((_resolve, _reject) => {
      this.sendWindowCapacityUpdate = () => {
        this.abortController.signal.removeEventListener("abort", abort);
        _resolve(void 0);
      };
      reject = _reject;
    });
  }
  handleWindowUpdate(header) {
    this.log?.trace("stream received window update id=%s", this._id);
    this.processFlags(header.flag);
    const available = this.sendWindowCapacity;
    this.sendWindowCapacity += header.length;
    if (available === 0 && header.length > 0) {
      this.sendWindowCapacityUpdate?.();
    }
  }
  async handleData(header, readData) {
    this.log?.trace("stream received data id=%s", this._id);
    this.processFlags(header.flag);
    if (this.recvWindowCapacity < header.length) {
      throw new CodeError("receive window exceeded", ERR_RECV_WINDOW_EXCEEDED, { available: this.recvWindowCapacity, recv: header.length });
    }
    const data = await readData();
    this.recvWindowCapacity -= header.length;
    this.sourceInput.push(data);
  }
  processFlags(flags) {
    if ((flags & Flag.ACK) === Flag.ACK) {
      if (this.state === StreamState.SYNSent) {
        this.state = StreamState.Established;
      }
    }
    if ((flags & Flag.FIN) === Flag.FIN) {
      this.closeRead();
    }
    if ((flags & Flag.RST) === Flag.RST) {
      this.reset();
    }
  }
  finish() {
    this.log?.trace("stream finished id=%s", this._id);
    this.state = StreamState.Finished;
    this.stat.timeline.close = Date.now();
    this.onStreamEnd();
  }
  getSendFlags() {
    switch (this.state) {
      case StreamState.Init:
        this.state = StreamState.SYNSent;
        return Flag.SYN;
      case StreamState.SYNReceived:
        this.state = StreamState.Established;
        return Flag.ACK;
      default:
        return 0;
    }
  }
  sendWindowUpdate() {
    const flags = this.getSendFlags();
    const now = Date.now();
    const rtt = this.getRTT();
    if (flags === 0 && rtt > 0 && now - this.epochStart < rtt * 4) {
      this.recvWindow = Math.min(this.recvWindow * 2, this.config.maxStreamWindowSize);
    }
    if (this.recvWindowCapacity >= this.recvWindow && flags === 0) {
      return;
    }
    const delta = this.recvWindow - this.recvWindowCapacity;
    this.recvWindowCapacity = this.recvWindow;
    this.epochStart = now;
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: flags,
      streamID: this._id,
      length: delta
    });
  }
  sendData(data) {
    const flags = this.getSendFlags();
    this.sendFrame({
      type: FrameType.Data,
      flag: flags,
      streamID: this._id,
      length: data.length
    }, data);
  }
  sendClose() {
    const flags = this.getSendFlags() | Flag.FIN;
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: flags,
      streamID: this._id,
      length: 0
    });
  }
  sendReset() {
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: Flag.RST,
      streamID: this._id,
      length: 0
    });
  }
};

// ../../node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.js
var YAMUX_PROTOCOL_ID = "/yamux/1.0.0";
var Yamux = class {
  constructor(init = {}) {
    __publicField(this, "protocol", YAMUX_PROTOCOL_ID);
    __publicField(this, "_init");
    this._init = init;
  }
  createStreamMuxer(init) {
    return new YamuxMuxer({
      ...this._init,
      ...init
    });
  }
};
var YamuxMuxer = class {
  constructor(init) {
    __publicField(this, "protocol", YAMUX_PROTOCOL_ID);
    __publicField(this, "source");
    __publicField(this, "sink");
    __publicField(this, "_init");
    __publicField(this, "config");
    __publicField(this, "log");
    __publicField(this, "closeController");
    __publicField(this, "nextStreamID");
    __publicField(this, "_streams");
    __publicField(this, "nextPingID");
    __publicField(this, "activePing");
    __publicField(this, "rtt");
    __publicField(this, "client");
    __publicField(this, "localGoAway");
    __publicField(this, "remoteGoAway");
    __publicField(this, "numInboundStreams");
    __publicField(this, "numOutboundStreams");
    __publicField(this, "onIncomingStream");
    __publicField(this, "onStreamEnd");
    this._init = init;
    this.client = init.direction === "outbound";
    this.config = { ...defaultConfig, ...init };
    this.log = this.config.log;
    verifyConfig(this.config);
    this.closeController = new AbortController();
    this.onIncomingStream = init.onIncomingStream;
    this.onStreamEnd = init.onStreamEnd;
    this._streams = /* @__PURE__ */ new Map();
    this.source = pushable({
      onEnd: (err) => {
        this.log?.trace("muxer source ended");
        this.close(err);
      }
    });
    this.sink = async (source) => {
      let signal;
      if (this._init.signal != null) {
        signal = anySignal([this.closeController.signal, this._init.signal]);
      }
      source = abortableSource(source, signal ?? this.closeController.signal, { returnOnAbort: true });
      let reason, error;
      try {
        const decoder = new Decoder(source);
        await pipe(decoder.emitFrames.bind(decoder), async (source2) => {
          for await (const { header, readData } of source2) {
            await this.handleFrame(header, readData);
          }
        });
        reason = GoAwayCode.NormalTermination;
      } catch (err) {
        const errCode = err.code;
        if (PROTOCOL_ERRORS.has(errCode)) {
          this.log?.error("protocol error in sink", err);
          reason = GoAwayCode.ProtocolError;
        } else {
          this.log?.error("internal error in sink", err);
          reason = GoAwayCode.InternalError;
        }
        error = err;
      } finally {
        if (signal != null) {
          signal.clear();
        }
      }
      this.log?.trace("muxer sink ended");
      this.close(error, reason);
    };
    this.numInboundStreams = 0;
    this.numOutboundStreams = 0;
    this.nextStreamID = this.client ? 1 : 2;
    this.nextPingID = 0;
    this.rtt = 0;
    this.log?.trace("muxer created");
    if (this.config.enableKeepAlive) {
      this.keepAliveLoop().catch((e) => this.log?.error("keepalive error: %s", e));
    }
  }
  get streams() {
    return Array.from(this._streams.values());
  }
  newStream(name) {
    if (this.remoteGoAway !== void 0) {
      throw new CodeError("muxer closed remotely", ERR_MUXER_REMOTE_CLOSED);
    }
    if (this.localGoAway !== void 0) {
      throw new CodeError("muxer closed locally", ERR_MUXER_LOCAL_CLOSED);
    }
    const id = this.nextStreamID;
    this.nextStreamID += 2;
    if (this.numOutboundStreams >= this.config.maxOutboundStreams) {
      throw new CodeError("max outbound streams exceeded", ERR_MAX_OUTBOUND_STREAMS_EXCEEDED);
    }
    this.log?.trace("new outgoing stream id=%s", id);
    const stream = this._newStream(id, name, StreamState.Init, "outbound");
    this._streams.set(id, stream);
    this.numOutboundStreams++;
    stream.sendWindowUpdate();
    return stream;
  }
  async ping() {
    if (this.remoteGoAway !== void 0) {
      throw new CodeError("muxer closed remotely", ERR_MUXER_REMOTE_CLOSED);
    }
    if (this.localGoAway !== void 0) {
      throw new CodeError("muxer closed locally", ERR_MUXER_LOCAL_CLOSED);
    }
    if (this.activePing === void 0) {
      let _resolve = () => {
      };
      this.activePing = {
        id: this.nextPingID++,
        promise: new Promise((resolve, reject) => {
          const closed = () => {
            reject(new CodeError("muxer closed locally", ERR_MUXER_LOCAL_CLOSED));
          };
          this.closeController.signal.addEventListener("abort", closed, { once: true });
          _resolve = () => {
            this.closeController.signal.removeEventListener("abort", closed);
            resolve();
          };
        }),
        resolve: _resolve
      };
      const start = Date.now();
      this.sendPing(this.activePing.id);
      try {
        await this.activePing.promise;
      } finally {
        delete this.activePing;
      }
      const end = Date.now();
      this.rtt = end - start;
    } else {
      await this.activePing.promise;
    }
    return this.rtt;
  }
  getRTT() {
    return this.rtt;
  }
  close(err, reason) {
    if (this.closeController.signal.aborted) {
      return;
    }
    reason = reason ?? (err === void 0 ? GoAwayCode.InternalError : GoAwayCode.NormalTermination);
    if (err != null) {
      this.log?.error("muxer close reason=%s error=%s", GoAwayCode[reason], err);
    } else {
      this.log?.trace("muxer close reason=%s", GoAwayCode[reason]);
    }
    if (err === void 0) {
      for (const stream of this._streams.values()) {
        stream.close();
      }
    } else {
      for (const stream of this._streams.values()) {
        stream.abort(err);
      }
    }
    this.sendGoAway(reason);
    this._closeMuxer();
  }
  isClosed() {
    return this.closeController.signal.aborted;
  }
  _closeMuxer() {
    this.closeController.abort();
    this.source.end();
  }
  _newStream(id, name, state, direction) {
    if (this._streams.get(id) != null) {
      throw new CodeError("Stream already exists", ERR_STREAM_ALREADY_EXISTS, { id });
    }
    const stream = new YamuxStream({
      id,
      name,
      state,
      direction,
      sendFrame: this.sendFrame.bind(this),
      onStreamEnd: () => {
        this.closeStream(id);
        this.onStreamEnd?.(stream);
      },
      log: this.log,
      config: this.config,
      getRTT: this.getRTT.bind(this)
    });
    return stream;
  }
  closeStream(id) {
    if (this.client === (id % 2 === 0)) {
      this.numInboundStreams--;
    } else {
      this.numOutboundStreams--;
    }
    this._streams.delete(id);
  }
  async keepAliveLoop() {
    const abortPromise = new Promise((_resolve, reject) => {
      this.closeController.signal.addEventListener("abort", reject, { once: true });
    });
    this.log?.trace("muxer keepalive enabled interval=%s", this.config.keepAliveInterval);
    while (true) {
      let timeoutId;
      try {
        await Promise.race([
          abortPromise,
          new Promise((resolve) => {
            timeoutId = setTimeout(resolve, this.config.keepAliveInterval);
          })
        ]);
        this.ping().catch((e) => this.log?.error("ping error: %s", e));
      } catch (e) {
        clearInterval(timeoutId);
        return;
      }
    }
  }
  async handleFrame(header, readData) {
    const { streamID, type, length } = header;
    this.log?.trace("received frame %s", stringifyHeader(header));
    if (streamID === 0) {
      switch (type) {
        case FrameType.Ping: {
          this.handlePing(header);
          return;
        }
        case FrameType.GoAway: {
          this.handleGoAway(length);
          return;
        }
        default:
          throw new CodeError("Invalid frame type", ERR_INVALID_FRAME, { header });
      }
    } else {
      switch (header.type) {
        case FrameType.Data:
        case FrameType.WindowUpdate: {
          await this.handleStreamMessage(header, readData);
          return;
        }
        default:
          throw new CodeError("Invalid frame type", ERR_INVALID_FRAME, { header });
      }
    }
  }
  handlePing(header) {
    if (header.flag === Flag.SYN) {
      this.log?.trace("received ping request pingId=%s", header.length);
      this.sendPing(header.length, Flag.ACK);
    } else if (header.flag === Flag.ACK) {
      this.log?.trace("received ping response pingId=%s", header.length);
      this.handlePingResponse(header.length);
    } else {
      throw new CodeError("Invalid frame flag", ERR_INVALID_FRAME, { header });
    }
  }
  handlePingResponse(pingId) {
    if (this.activePing === void 0) {
      throw new CodeError("ping not requested", ERR_UNREQUESTED_PING);
    }
    if (this.activePing.id !== pingId) {
      throw new CodeError("ping doesn't match our id", ERR_NOT_MATCHING_PING);
    }
    this.activePing.resolve();
  }
  handleGoAway(reason) {
    this.log?.trace("received GoAway reason=%s", GoAwayCode[reason] ?? "unknown");
    this.remoteGoAway = reason;
    for (const stream of this._streams.values()) {
      stream.reset();
    }
    this._closeMuxer();
  }
  async handleStreamMessage(header, readData) {
    const { streamID, flag, type } = header;
    if ((flag & Flag.SYN) === Flag.SYN) {
      this.incomingStream(streamID);
    }
    const stream = this._streams.get(streamID);
    if (stream === void 0) {
      if (type === FrameType.Data) {
        this.log?.("discarding data for stream id=%s", streamID);
        if (readData === void 0) {
          throw new Error("unreachable");
        }
        await readData();
      } else {
        this.log?.("frame for missing stream id=%s", streamID);
      }
      return;
    }
    switch (type) {
      case FrameType.WindowUpdate: {
        stream.handleWindowUpdate(header);
        return;
      }
      case FrameType.Data: {
        if (readData === void 0) {
          throw new Error("unreachable");
        }
        await stream.handleData(header, readData);
        return;
      }
      default:
        throw new Error("unreachable");
    }
  }
  incomingStream(id) {
    if (this.client !== (id % 2 === 0)) {
      throw new CodeError("both endpoints are clients", ERR_BOTH_CLIENTS);
    }
    if (this._streams.has(id)) {
      return;
    }
    this.log?.trace("new incoming stream id=%s", id);
    if (this.localGoAway !== void 0) {
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: Flag.RST,
        streamID: id,
        length: 0
      });
      return;
    }
    if (this.numInboundStreams >= this.config.maxInboundStreams) {
      this.log?.("maxIncomingStreams exceeded, forcing stream reset");
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: Flag.RST,
        streamID: id,
        length: 0
      });
      return;
    }
    const stream = this._newStream(id, void 0, StreamState.SYNReceived, "inbound");
    this.numInboundStreams++;
    this._streams.set(id, stream);
    this.onIncomingStream?.(stream);
  }
  sendFrame(header, data) {
    this.log?.trace("sending frame %s", stringifyHeader(header));
    if (header.type === FrameType.Data) {
      if (data === void 0) {
        throw new CodeError("invalid frame", ERR_INVALID_FRAME);
      }
      this.source.push(encodeHeader(header));
      this.source.push(data);
    } else {
      this.source.push(encodeHeader(header));
    }
  }
  sendPing(pingId, flag = Flag.SYN) {
    if (flag === Flag.SYN) {
      this.log?.trace("sending ping request pingId=%s", pingId);
    } else {
      this.log?.trace("sending ping response pingId=%s", pingId);
    }
    this.sendFrame({
      type: FrameType.Ping,
      flag,
      streamID: 0,
      length: pingId
    });
  }
  sendGoAway(reason = GoAwayCode.NormalTermination) {
    this.log?.("sending GoAway reason=%s", GoAwayCode[reason]);
    this.localGoAway = reason;
    this.sendFrame({
      type: FrameType.GoAway,
      flag: 0,
      streamID: 0,
      length: reason
    });
  }
};

// ../../node_modules/@chainsafe/libp2p-yamux/dist/src/index.js
function yamux(init = {}) {
  return () => new Yamux(init);
}
export {
  GoAwayCode,
  yamux
};
//# sourceMappingURL=@chainsafe_libp2p-yamux.js.map
