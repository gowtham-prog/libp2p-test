import {
  pDefer
} from "./chunk-YUNCDTIA.js";
import {
  Uint8ArrayList
} from "./chunk-ADNOUI46.js";
import "./chunk-SD7KC3ZF.js";
import "./chunk-QA7JUXLP.js";
import "./chunk-GSGWBNT6.js";
import "./chunk-CWJX2WJ3.js";

// ../../node_modules/it-batched-bytes/dist/src/index.js
function isAsyncIterable(thing) {
  return thing[Symbol.asyncIterator] != null;
}
var DEFAULT_BATCH_SIZE = 1024 * 1024;
var DEFAULT_SERIALIZE = (buf, list) => {
  list.append(buf);
};
function batchedBytes(source, options) {
  if (isAsyncIterable(source)) {
    return async function* () {
      let buffer = new Uint8ArrayList();
      let ended = false;
      let deferred = pDefer();
      let size = Number(options?.size ?? DEFAULT_BATCH_SIZE);
      if (isNaN(size) || size === 0 || size < 0) {
        size = DEFAULT_BATCH_SIZE;
      }
      if (size !== Math.round(size)) {
        throw new Error("Batch size must be an integer");
      }
      const yieldAfter = options?.yieldAfter ?? 0;
      const serialize = options?.serialize ?? DEFAULT_SERIALIZE;
      void Promise.resolve().then(async () => {
        try {
          let timeout;
          for await (const buf of source) {
            serialize(buf, buffer);
            if (buffer.byteLength >= size) {
              clearTimeout(timeout);
              deferred.resolve();
              continue;
            }
            timeout = setTimeout(() => {
              deferred.resolve();
            }, yieldAfter);
          }
          clearTimeout(timeout);
          deferred.resolve();
        } catch (err) {
          deferred.reject(err);
        } finally {
          ended = true;
        }
      });
      while (!ended) {
        await deferred.promise;
        deferred = pDefer();
        if (buffer.byteLength > 0) {
          const b = buffer;
          buffer = new Uint8ArrayList();
          yield b.subarray();
        }
      }
    }();
  }
  return function* () {
    const buffer = new Uint8ArrayList();
    let size = Number(options?.size ?? DEFAULT_BATCH_SIZE);
    if (isNaN(size) || size === 0 || size < 0) {
      size = DEFAULT_BATCH_SIZE;
    }
    if (size !== Math.round(size)) {
      throw new Error("Batch size must be an integer");
    }
    const serialize = options?.serialize ?? DEFAULT_SERIALIZE;
    for (const buf of source) {
      serialize(buf, buffer);
      if (buffer.byteLength >= size) {
        yield buffer.subarray(0, size);
        buffer.consume(size);
      }
    }
    if (buffer.byteLength > 0) {
      yield buffer.subarray();
    }
  }();
}
var src_default = batchedBytes;

// dep:it-batched-bytes
var it_batched_bytes_default = src_default;
export {
  it_batched_bytes_default as default
};
//# sourceMappingURL=it-batched-bytes.js.map
