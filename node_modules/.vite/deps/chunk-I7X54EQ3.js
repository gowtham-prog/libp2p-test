import {
  allocUnsafe
} from "./chunk-GSGWBNT6.js";

// ../../node_modules/byte-access/dist/src/index.js
function accessor(buf) {
  if (buf instanceof Uint8Array) {
    return {
      get(index) {
        return buf[index];
      },
      set(index, value) {
        buf[index] = value;
      }
    };
  }
  return {
    get(index) {
      return buf.get(index);
    },
    set(index, value) {
      buf.set(index, value);
    }
  };
}

// ../../node_modules/longbits/dist/src/index.js
var TWO_32 = 4294967296;
var LongBits = class {
  constructor(hi = 0, lo = 0) {
    this.hi = hi;
    this.lo = lo;
  }
  toBigInt(unsigned2) {
    if (unsigned2 === true) {
      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
    }
    if (this.hi >>> 31 !== 0) {
      const lo = ~this.lo + 1 >>> 0;
      let hi = ~this.hi >>> 0;
      if (lo === 0) {
        hi = hi + 1 >>> 0;
      }
      return -(BigInt(lo) + (BigInt(hi) << 32n));
    }
    return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
  }
  toNumber(unsigned2) {
    return Number(this.toBigInt(unsigned2));
  }
  zzDecode() {
    const mask = -(this.lo & 1);
    const lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    const hi = (this.hi >>> 1 ^ mask) >>> 0;
    return new LongBits(hi, lo);
  }
  zzEncode() {
    const mask = this.hi >> 31;
    const hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    const lo = (this.lo << 1 ^ mask) >>> 0;
    return new LongBits(hi, lo);
  }
  toBytes(buf, offset = 0) {
    const access = accessor(buf);
    while (this.hi > 0) {
      access.set(offset++, this.lo & 127 | 128);
      this.lo = (this.lo >>> 7 | this.hi << 25) >>> 0;
      this.hi >>>= 7;
    }
    while (this.lo > 127) {
      access.set(offset++, this.lo & 127 | 128);
      this.lo = this.lo >>> 7;
    }
    access.set(offset++, this.lo);
  }
  static fromBigInt(value) {
    if (value === 0n) {
      return new LongBits();
    }
    const negative = value < 0;
    if (negative) {
      value = -value;
    }
    let hi = Number(value >> 32n) | 0;
    let lo = Number(value - (BigInt(hi) << 32n)) | 0;
    if (negative) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > TWO_32) {
        lo = 0;
        if (++hi > TWO_32) {
          hi = 0;
        }
      }
    }
    return new LongBits(hi, lo);
  }
  static fromNumber(value) {
    if (value === 0) {
      return new LongBits();
    }
    const sign = value < 0;
    if (sign) {
      value = -value;
    }
    let lo = value >>> 0;
    let hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295) {
          hi = 0;
        }
      }
    }
    return new LongBits(hi, lo);
  }
  static fromBytes(buf, offset = 0) {
    const access = accessor(buf);
    const bits = new LongBits();
    let i = 0;
    if (buf.length - offset > 4) {
      for (; i < 4; ++i) {
        bits.lo = (bits.lo | (access.get(offset) & 127) << i * 7) >>> 0;
        if (access.get(offset++) < 128) {
          return bits;
        }
      }
      bits.lo = (bits.lo | (access.get(offset) & 127) << 28) >>> 0;
      bits.hi = (bits.hi | (access.get(offset) & 127) >> 4) >>> 0;
      if (access.get(offset++) < 128) {
        return bits;
      }
      i = 0;
    } else {
      for (; i < 4; ++i) {
        if (offset >= buf.length) {
          throw RangeError(`index out of range: ${offset} > ${buf.length}`);
        }
        bits.lo = (bits.lo | (access.get(offset) & 127) << i * 7) >>> 0;
        if (access.get(offset++) < 128) {
          return bits;
        }
      }
    }
    if (buf.length - offset > 4) {
      for (; i < 5; ++i) {
        bits.hi = (bits.hi | (access.get(offset) & 127) << i * 7 + 3) >>> 0;
        if (access.get(offset++) < 128) {
          return bits;
        }
      }
    } else if (offset < buf.byteLength) {
      for (; i < 5; ++i) {
        if (offset >= buf.length) {
          throw RangeError(`index out of range: ${offset} > ${buf.length}`);
        }
        bits.hi = (bits.hi | (access.get(offset) & 127) << i * 7 + 3) >>> 0;
        if (access.get(offset++) < 128) {
          return bits;
        }
      }
    }
    throw RangeError("invalid varint encoding");
  }
};

// ../../node_modules/uint8-varint/dist/src/index.js
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var unsigned = {
  encodingLength(value) {
    if (value < N1) {
      return 1;
    }
    if (value < N2) {
      return 2;
    }
    if (value < N3) {
      return 3;
    }
    if (value < N4) {
      return 4;
    }
    if (value < N5) {
      return 5;
    }
    if (value < N6) {
      return 6;
    }
    if (value < N7) {
      return 7;
    }
    if (value < N8) {
      return 8;
    }
    if (value < N9) {
      return 9;
    }
    return 10;
  },
  encode(value, buf, offset = 0) {
    if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {
      throw new RangeError("Could not encode varint");
    }
    if (buf == null) {
      buf = allocUnsafe(unsigned.encodingLength(value));
    }
    LongBits.fromNumber(value).toBytes(buf, offset);
    return buf;
  },
  decode(buf, offset = 0) {
    return LongBits.fromBytes(buf, offset).toNumber(true);
  }
};
var signed = {
  encodingLength(value) {
    if (value < 0) {
      return 10;
    }
    return unsigned.encodingLength(value);
  },
  encode(value, buf, offset) {
    if (buf == null) {
      buf = allocUnsafe(signed.encodingLength(value));
    }
    if (value < 0) {
      LongBits.fromNumber(value).toBytes(buf, offset);
      return buf;
    }
    return unsigned.encode(value, buf, offset);
  },
  decode(buf, offset = 0) {
    return LongBits.fromBytes(buf, offset).toNumber(false);
  }
};
var zigzag = {
  encodingLength(value) {
    return unsigned.encodingLength(value >= 0 ? value * 2 : value * -2 - 1);
  },
  encode(value, buf, offset) {
    value = value >= 0 ? value * 2 : value * -2 - 1;
    return unsigned.encode(value, buf, offset);
  },
  decode(buf, offset = 0) {
    const value = unsigned.decode(buf, offset);
    return (value & 1) !== 0 ? (value + 1) / -2 : value / 2;
  }
};

export {
  unsigned,
  signed,
  zigzag
};
//# sourceMappingURL=chunk-I7X54EQ3.js.map
