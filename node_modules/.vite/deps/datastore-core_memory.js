import {
  src_default as src_default4
} from "./chunk-MVGWCFMI.js";
import {
  src_default as src_default3
} from "./chunk-6PM5AHNX.js";
import {
  src_default
} from "./chunk-H57KYGDJ.js";
import {
  src_default as src_default2
} from "./chunk-QGGXSAZI.js";
import "./chunk-CKY2MTBY.js";
import {
  Key
} from "./chunk-3WS7VOEM.js";
import "./chunk-NIJTSU5Z.js";
import {
  require_err_code
} from "./chunk-5PN3INJP.js";
import "./chunk-N67GK3BH.js";
import "./chunk-HTALK6FU.js";
import "./chunk-JKZ6URRT.js";
import "./chunk-GSGWBNT6.js";
import {
  __publicField,
  __toESM
} from "./chunk-CWJX2WJ3.js";

// ../../node_modules/it-sort/dist/src/index.js
function isAsyncIterable(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function sort(source, sorter) {
  if (isAsyncIterable(source)) {
    return async function* () {
      const arr = await src_default3(source);
      yield* arr.sort(sorter);
    }();
  }
  return function* () {
    const arr = src_default3(source);
    yield* arr.sort(sorter);
  }();
}
var src_default5 = sort;

// ../../node_modules/datastore-core/dist/src/base.js
var BaseDatastore = class {
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options);
      yield key;
    }
  }
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield {
        key,
        value: await this.get(key, options)
      };
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await src_default(this.putMany(puts, options));
        puts = [];
        await src_default(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default2(it, (e) => e.key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => src_default2(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => src_default5(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      const offset = q.offset;
      it = src_default2(it, () => i++ >= offset);
    }
    if (q.limit != null) {
      it = src_default4(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default2(it, (key) => key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => src_default2(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => src_default5(it2, f), it);
    }
    if (q.offset != null) {
      const offset = q.offset;
      let i = 0;
      it = src_default2(it, () => i++ >= offset);
    }
    if (q.limit != null) {
      it = src_default4(it, q.limit);
    }
    return it;
  }
};

// ../../node_modules/datastore-core/dist/src/errors.js
var import_err_code = __toESM(require_err_code(), 1);
function notFoundError(err) {
  err = err ?? new Error("Not Found");
  return (0, import_err_code.default)(err, "ERR_NOT_FOUND");
}

// ../../node_modules/datastore-core/dist/src/memory.js
var MemoryDatastore = class extends BaseDatastore {
  constructor() {
    super();
    __publicField(this, "data");
    this.data = /* @__PURE__ */ new Map();
  }
  put(key, val) {
    this.data.set(key.toString(), val);
    return key;
  }
  get(key) {
    const result = this.data.get(key.toString());
    if (result == null) {
      throw notFoundError();
    }
    return result;
  }
  has(key) {
    return this.data.has(key.toString());
  }
  delete(key) {
    this.data.delete(key.toString());
  }
  *_all() {
    for (const [key, value] of this.data.entries()) {
      yield { key: new Key(key), value };
    }
  }
  *_allKeys() {
    for (const key of this.data.keys()) {
      yield new Key(key);
    }
  }
};
export {
  MemoryDatastore
};
//# sourceMappingURL=datastore-core_memory.js.map
