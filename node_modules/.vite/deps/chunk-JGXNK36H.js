import {
  encode
} from "./chunk-PZSXRLLQ.js";
import {
  unsigned
} from "./chunk-I7X54EQ3.js";
import {
  require_err_code
} from "./chunk-5PN3INJP.js";
import {
  pushable
} from "./chunk-GCFO4FX4.js";
import {
  Uint8ArrayList
} from "./chunk-ADNOUI46.js";
import {
  __toESM
} from "./chunk-CWJX2WJ3.js";

// ../../node_modules/it-pb-stream/dist/src/index.js
var import_err_code = __toESM(require_err_code(), 1);
var defaultLengthDecoder = (buf) => {
  return unsigned.decode(buf);
};
defaultLengthDecoder.bytes = 0;
function pbStream(duplex, opts) {
  const write = pushable();
  duplex.sink(write).catch((err) => {
    write.end(err);
  });
  duplex.sink = async (source2) => {
    for await (const buf of source2) {
      write.push(buf);
    }
    write.end();
  };
  let source = duplex.source;
  if (duplex.source[Symbol.iterator] != null) {
    source = duplex.source[Symbol.iterator]();
  } else if (duplex.source[Symbol.asyncIterator] != null) {
    source = duplex.source[Symbol.asyncIterator]();
  }
  const readBuffer = new Uint8ArrayList();
  const W = {
    read: async (bytes) => {
      if (bytes == null) {
        const { done, value } = await source.next();
        if (done === true) {
          return new Uint8ArrayList();
        }
        return value;
      }
      while (readBuffer.byteLength < bytes) {
        const { value, done } = await source.next();
        if (done === true) {
          throw (0, import_err_code.default)(new Error("unexpected end of input"), "ERR_UNEXPECTED_EOF");
        }
        readBuffer.append(value);
      }
      const buf = readBuffer.sublist(0, bytes);
      readBuffer.consume(bytes);
      return buf;
    },
    readLP: async () => {
      let dataLength = -1;
      const lengthBuffer = new Uint8ArrayList();
      const decodeLength = opts?.lengthDecoder ?? defaultLengthDecoder;
      while (true) {
        lengthBuffer.append(await W.read(1));
        try {
          dataLength = decodeLength(lengthBuffer);
        } catch (err) {
          if (err instanceof RangeError) {
            continue;
          }
          throw err;
        }
        if (dataLength > -1) {
          break;
        }
        if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {
          throw (0, import_err_code.default)(new Error("message length length too long"), "ERR_MSG_LENGTH_TOO_LONG");
        }
      }
      if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {
        throw (0, import_err_code.default)(new Error("message length too long"), "ERR_MSG_DATA_TOO_LONG");
      }
      return W.read(dataLength);
    },
    readPB: async (proto) => {
      const value = await W.readLP();
      if (value == null) {
        throw new Error("Value is null");
      }
      const buf = value instanceof Uint8Array ? value : value.subarray();
      return proto.decode(buf);
    },
    write: (data) => {
      if (data instanceof Uint8Array) {
        write.push(data);
      } else {
        write.push(data.subarray());
      }
    },
    writeLP: (data) => {
      W.write(encode.single(data, opts));
    },
    writePB: (data, proto) => {
      W.writeLP(proto.encode(data));
    },
    pb: (proto) => {
      return {
        read: async () => W.readPB(proto),
        write: (d) => {
          W.writePB(d, proto);
        },
        unwrap: () => W
      };
    },
    unwrap: () => {
      const originalStream = duplex.source;
      duplex.source = async function* () {
        yield* readBuffer;
        yield* originalStream;
      }();
      return duplex;
    }
  };
  return W;
}

export {
  pbStream
};
//# sourceMappingURL=chunk-JGXNK36H.js.map
