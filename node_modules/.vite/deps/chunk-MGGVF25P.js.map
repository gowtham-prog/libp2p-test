{
  "version": 3,
  "sources": ["../../../../../node_modules/node-forge/lib/hmac.js", "../../../../../node_modules/node-forge/lib/pbkdf2.js"],
  "sourcesContent": ["/**\n * Hash-based Message Authentication Code implementation. Requires a message\n * digest object that can be obtained, for example, from forge.md.sha1 or\n * forge.md.md5.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2012 Digital Bazaar, Inc. All rights reserved.\n */\nvar forge = require('./forge');\nrequire('./md');\nrequire('./util');\n\n/* HMAC API */\nvar hmac = module.exports = forge.hmac = forge.hmac || {};\n\n/**\n * Creates an HMAC object that uses the given message digest object.\n *\n * @return an HMAC object.\n */\nhmac.create = function() {\n  // the hmac key to use\n  var _key = null;\n\n  // the message digest to use\n  var _md = null;\n\n  // the inner padding\n  var _ipadding = null;\n\n  // the outer padding\n  var _opadding = null;\n\n  // hmac context\n  var ctx = {};\n\n  /**\n   * Starts or restarts the HMAC with the given key and message digest.\n   *\n   * @param md the message digest to use, null to reuse the previous one,\n   *           a string to use builtin 'sha1', 'md5', 'sha256'.\n   * @param key the key to use as a string, array of bytes, byte buffer,\n   *           or null to reuse the previous key.\n   */\n  ctx.start = function(md, key) {\n    if(md !== null) {\n      if(typeof md === 'string') {\n        // create builtin message digest\n        md = md.toLowerCase();\n        if(md in forge.md.algorithms) {\n          _md = forge.md.algorithms[md].create();\n        } else {\n          throw new Error('Unknown hash algorithm \"' + md + '\"');\n        }\n      } else {\n        // store message digest\n        _md = md;\n      }\n    }\n\n    if(key === null) {\n      // reuse previous key\n      key = _key;\n    } else {\n      if(typeof key === 'string') {\n        // convert string into byte buffer\n        key = forge.util.createBuffer(key);\n      } else if(forge.util.isArray(key)) {\n        // convert byte array into byte buffer\n        var tmp = key;\n        key = forge.util.createBuffer();\n        for(var i = 0; i < tmp.length; ++i) {\n          key.putByte(tmp[i]);\n        }\n      }\n\n      // if key is longer than blocksize, hash it\n      var keylen = key.length();\n      if(keylen > _md.blockLength) {\n        _md.start();\n        _md.update(key.bytes());\n        key = _md.digest();\n      }\n\n      // mix key into inner and outer padding\n      // ipadding = [0x36 * blocksize] ^ key\n      // opadding = [0x5C * blocksize] ^ key\n      _ipadding = forge.util.createBuffer();\n      _opadding = forge.util.createBuffer();\n      keylen = key.length();\n      for(var i = 0; i < keylen; ++i) {\n        var tmp = key.at(i);\n        _ipadding.putByte(0x36 ^ tmp);\n        _opadding.putByte(0x5C ^ tmp);\n      }\n\n      // if key is shorter than blocksize, add additional padding\n      if(keylen < _md.blockLength) {\n        var tmp = _md.blockLength - keylen;\n        for(var i = 0; i < tmp; ++i) {\n          _ipadding.putByte(0x36);\n          _opadding.putByte(0x5C);\n        }\n      }\n      _key = key;\n      _ipadding = _ipadding.bytes();\n      _opadding = _opadding.bytes();\n    }\n\n    // digest is done like so: hash(opadding | hash(ipadding | message))\n\n    // prepare to do inner hash\n    // hash(ipadding | message)\n    _md.start();\n    _md.update(_ipadding);\n  };\n\n  /**\n   * Updates the HMAC with the given message bytes.\n   *\n   * @param bytes the bytes to update with.\n   */\n  ctx.update = function(bytes) {\n    _md.update(bytes);\n  };\n\n  /**\n   * Produces the Message Authentication Code (MAC).\n   *\n   * @return a byte buffer containing the digest value.\n   */\n  ctx.getMac = function() {\n    // digest is done like so: hash(opadding | hash(ipadding | message))\n    // here we do the outer hashing\n    var inner = _md.digest().bytes();\n    _md.start();\n    _md.update(_opadding);\n    _md.update(inner);\n    return _md.digest();\n  };\n  // alias for getMac\n  ctx.digest = ctx.getMac;\n\n  return ctx;\n};\n", "/**\n * Password-Based Key-Derivation Function #2 implementation.\n *\n * See RFC 2898 for details.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./hmac');\nrequire('./md');\nrequire('./util');\n\nvar pkcs5 = forge.pkcs5 = forge.pkcs5 || {};\n\nvar crypto;\nif(forge.util.isNodejs && !forge.options.usePureJavaScript) {\n  crypto = require('crypto');\n}\n\n/**\n * Derives a key from a password.\n *\n * @param p the password as a binary-encoded string of bytes.\n * @param s the salt as a binary-encoded string of bytes.\n * @param c the iteration count, a positive integer.\n * @param dkLen the intended length, in bytes, of the derived key,\n *          (max: 2^32 - 1) * hash length of the PRF.\n * @param [md] the message digest (or algorithm identifier as a string) to use\n *          in the PRF, defaults to SHA-1.\n * @param [callback(err, key)] presence triggers asynchronous version, called\n *          once the operation completes.\n *\n * @return the derived key, as a binary-encoded string of bytes, for the\n *           synchronous version (if no callback is specified).\n */\nmodule.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(\n  p, s, c, dkLen, md, callback) {\n  if(typeof md === 'function') {\n    callback = md;\n    md = null;\n  }\n\n  // use native implementation if possible and not disabled, note that\n  // some node versions only support SHA-1, others allow digest to be changed\n  if(forge.util.isNodejs && !forge.options.usePureJavaScript &&\n    crypto.pbkdf2 && (md === null || typeof md !== 'object') &&\n    (crypto.pbkdf2Sync.length > 4 || (!md || md === 'sha1'))) {\n    if(typeof md !== 'string') {\n      // default prf to SHA-1\n      md = 'sha1';\n    }\n    p = Buffer.from(p, 'binary');\n    s = Buffer.from(s, 'binary');\n    if(!callback) {\n      if(crypto.pbkdf2Sync.length === 4) {\n        return crypto.pbkdf2Sync(p, s, c, dkLen).toString('binary');\n      }\n      return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString('binary');\n    }\n    if(crypto.pbkdf2Sync.length === 4) {\n      return crypto.pbkdf2(p, s, c, dkLen, function(err, key) {\n        if(err) {\n          return callback(err);\n        }\n        callback(null, key.toString('binary'));\n      });\n    }\n    return crypto.pbkdf2(p, s, c, dkLen, md, function(err, key) {\n      if(err) {\n        return callback(err);\n      }\n      callback(null, key.toString('binary'));\n    });\n  }\n\n  if(typeof md === 'undefined' || md === null) {\n    // default prf to SHA-1\n    md = 'sha1';\n  }\n  if(typeof md === 'string') {\n    if(!(md in forge.md.algorithms)) {\n      throw new Error('Unknown hash algorithm: ' + md);\n    }\n    md = forge.md[md].create();\n  }\n\n  var hLen = md.digestLength;\n\n  /* 1. If dkLen > (2^32 - 1) * hLen, output \"derived key too long\" and\n    stop. */\n  if(dkLen > (0xFFFFFFFF * hLen)) {\n    var err = new Error('Derived key is too long.');\n    if(callback) {\n      return callback(err);\n    }\n    throw err;\n  }\n\n  /* 2. Let len be the number of hLen-octet blocks in the derived key,\n    rounding up, and let r be the number of octets in the last\n    block:\n\n    len = CEIL(dkLen / hLen),\n    r = dkLen - (len - 1) * hLen. */\n  var len = Math.ceil(dkLen / hLen);\n  var r = dkLen - (len - 1) * hLen;\n\n  /* 3. For each block of the derived key apply the function F defined\n    below to the password P, the salt S, the iteration count c, and\n    the block index to compute the block:\n\n    T_1 = F(P, S, c, 1),\n    T_2 = F(P, S, c, 2),\n    ...\n    T_len = F(P, S, c, len),\n\n    where the function F is defined as the exclusive-or sum of the\n    first c iterates of the underlying pseudorandom function PRF\n    applied to the password P and the concatenation of the salt S\n    and the block index i:\n\n    F(P, S, c, i) = u_1 XOR u_2 XOR ... XOR u_c\n\n    where\n\n    u_1 = PRF(P, S || INT(i)),\n    u_2 = PRF(P, u_1),\n    ...\n    u_c = PRF(P, u_{c-1}).\n\n    Here, INT(i) is a four-octet encoding of the integer i, most\n    significant octet first. */\n  var prf = forge.hmac.create();\n  prf.start(md, p);\n  var dk = '';\n  var xor, u_c, u_c1;\n\n  // sync version\n  if(!callback) {\n    for(var i = 1; i <= len; ++i) {\n      // PRF(P, S || INT(i)) (first iteration)\n      prf.start(null, null);\n      prf.update(s);\n      prf.update(forge.util.int32ToBytes(i));\n      xor = u_c1 = prf.digest().getBytes();\n\n      // PRF(P, u_{c-1}) (other iterations)\n      for(var j = 2; j <= c; ++j) {\n        prf.start(null, null);\n        prf.update(u_c1);\n        u_c = prf.digest().getBytes();\n        // F(p, s, c, i)\n        xor = forge.util.xorBytes(xor, u_c, hLen);\n        u_c1 = u_c;\n      }\n\n      /* 4. Concatenate the blocks and extract the first dkLen octets to\n        produce a derived key DK:\n\n        DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */\n      dk += (i < len) ? xor : xor.substr(0, r);\n    }\n    /* 5. Output the derived key DK. */\n    return dk;\n  }\n\n  // async version\n  var i = 1, j;\n  function outer() {\n    if(i > len) {\n      // done\n      return callback(null, dk);\n    }\n\n    // PRF(P, S || INT(i)) (first iteration)\n    prf.start(null, null);\n    prf.update(s);\n    prf.update(forge.util.int32ToBytes(i));\n    xor = u_c1 = prf.digest().getBytes();\n\n    // PRF(P, u_{c-1}) (other iterations)\n    j = 2;\n    inner();\n  }\n\n  function inner() {\n    if(j <= c) {\n      prf.start(null, null);\n      prf.update(u_c1);\n      u_c = prf.digest().getBytes();\n      // F(p, s, c, i)\n      xor = forge.util.xorBytes(xor, u_c, hLen);\n      u_c1 = u_c;\n      ++j;\n      return forge.util.setImmediate(inner);\n    }\n\n    /* 4. Concatenate the blocks and extract the first dkLen octets to\n      produce a derived key DK:\n\n      DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */\n    dk += (i < len) ? xor : xor.substr(0, r);\n\n    ++i;\n    outer();\n  }\n\n  outer();\n};\n"],
  "mappings": "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",
  "names": ["err"]
}
